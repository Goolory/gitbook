## 📚C++

### 🏷const

**作用**

1、修饰变量，说明该变量不可以被改变

2、修饰指针，分为指向常量的指针（pointer to const 如：const int * p ）const在 * 之前，不能通过 * P来修改所指向的内容去的内容；常量指针，简称常指针：int * const p, * 在const之前，不能改变指向的位置

```c++
char g[] = "hello";
const char* p1 = g;  //指针变量，不能通过*p1 改变内容，可以改变位置
char * const p2 = g;  //常量指针，不能改变指针指向的位置；可以改变内容
```

3、修饰引用，指向常量的应用，用于形参类型，避免了拷贝，又避免了函数对值得修改；

```c++
void function(const int& var);
```

4、修饰成员函数，该成员函数内不能改变成员变量。

```c++
class A{
 int func() const; 
}
```

### 🏷 static

| static作用       | 存储区 | 初始化     | 作用域                                                       | 备注                                                         |
| ---------------- | ------ | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义全局静态变量 | 静态区 | 默认初始化 | 仅在声明它的文件中可见，不被其他文件所用                     | 在main函数执行前就分配了空间                                 |
| 局部静态变量     | 静态区 | 默认初始化 | 局部作用域                                                   | 当执行离开局部作用域后，该变量没有被销毁，任然驻留在内存中。 |
| 静态函数         |        |            | 仅在声明它的文件中可见，不被其他文件所用                     | 不要在头文件中声明static的全局函数，<br />不要在cpp内声明非static的全局函数.<br />如果要在多个cpp中重复使用该函数，就把它声明到头文件中<br />否则cpp内部声明应该加上static修饰 |
| 类的静态成员     |        |            |                                                              | 静态成员是类的所有对象中共享的成员，而不是某个对象的成员.<br />静态数据成员只存储一处，对所有对象共用。 |
| 类的静态函数     |        |            | 静态函数与静态成员一样，<br />不是对象成员，引用时不需要对象名 | 引用格式：<类名>::<静态成员函数名>(<参数>);                  |

### 🏷 extern

1、可以置于变量或者函数前，以声明变量或者函数的定义在别的文件中，提示编译器在遇到次变量和函数时在其他模块中寻找其定义

2、链接指定，当他和"C"一起连用时，`extern "c" void fun(int a, int b)`;这 告诉编译器在编译这个fun按照c的规则去翻译函数名

与include相比，extern引用另一个文件的范围小，include可以引用另一个文件的全部内容

### 🏷 explicit关键字

C++中的explicit关键字只能修饰只有一个参数的类构造函数，作用是表名该构造函数是显示的，而非隐式的，跟它对应的另一关键字是implicit，意思是隐藏的，类的构造函数默认下即声明为implicit

参考https://blog.csdn.net/guoyunfei123/article/details/89003369

### 🏷this指针

1、`this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象

2、当对一个对象调用成员函数时，编译程序先将对象的地址赋值给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式的使用 `this` 指针。

3、当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数指向这个成员函数所在对象的指针。

4、`this` 指针被隐含的声明为： `ClassName *const this` ,这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员中， `this` 指针的类型为 `const ClassName* const` ,这说明不能对 `this` 指针所指向的这种对象是不可修改的

5、 `this` 并不是常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this` )

6、在以下场景中，经常需要显示的应用 `this` 指针：

​	1、为实现对象的链式引用；

​	2、为了避免对同一对象进行赋值操作；

​	3、实现一些数据结构时，如：list

### 🏷 inline 内联函数

* 相当于把内联函数里的内容写在调用内联函数处
* 相当于不用执行进入函数的步骤，直接执行函数体；
* 相当于宏，却比宏多了类型检查，真正具有函数特性；
* 内联一般不包含循环、递归等复杂操作
* 在类声明中定义的函数，除了虚函数其他函数都会自动隐式地当成内联函数。

####  编译器对inline函数的处理步骤

1、将inline函数体复制到inline函数调用点处；

2、为所用inline函数中的局部变量分配内存空间；

3、将inline函数的输入参数和返回值映射到调用方法的局部变量空间中；

4、如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支（使GOTO）

#### 优缺点

**优点**

1、内联函数和宏函数一样将在被调用处进行代码展开，省去了参数压栈，栈帧开辟与回收，结果返回等，从而提高程序的运行速度；

2、内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换，而宏定义不会；

3、在类中声明的同时定义的成员函数，会自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义不行

4、内联函数在运行时可以调试，而宏定义不可以

**缺点**

1、代码膨胀💥。内联是一代码膨胀为代价，消除函数调用带来的开销。

2、inline函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不行on-inline可以直接链接

#### 虚函数（virtual）可以是内联函数吗？

* 虚函数可以是内联函数，内联可以修饰虚函数的，但是当虚函数表现多态性时不能内联
* 内联是在编译期内联，而虚函数的多态性是在运行期。编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时不可内联。
*  `inline virtual`  唯一内联的时候是：编译器知道调用的对象是哪个类 （如 `Base::who()` ,这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

``` c++
#include<iostream>
using namespace std;
class Base
{
  public:
    inline virtual void who()
    {
      cout << "kkk\n";
    }
    virtual ~Base(){}
};
class Derived : public Base
{
  public:
    inline void who()  // 不写inline时隐式内联
    {
      cout << "kkk";
    }
};
int main()
{
  Base b;
  b.who();  // 此处的虚函数是who()，是通过类Base的具体对象b来调用，编译器就能确定了
  
  // 此处的虚函数是通过指针调用的，呈多态性，需要在运行时期才能确定，所以不能内联
  Base* ptr = new Derived();
  ptr->who();
  return 0;
}
```

### 🏷 assert()

断言，是宏，而非函数。assert宏的原型定义在 `<assert.h>` c语言 -- `<cassert>` C++

 作用：如果他的条件返回错误，则终止程序执行。可以通过定义 `NOEBUG` 来关闭，需要定义在 `include<assert.h>`  之前 

```c++
#define NDEBUG
#include<assert.h>
assert(p != nullptr);
```

### 🏷 sizeof()

* sizeof对数组，得到整个数组占空间大小

* sizeof对指针，得到指针本身大小

  ​	sizefof(空类) = 1；[类的大小——sizeof 的研究(1)](https://www.jianshu.com/p/5163a2678171)

  ​	因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址，每个实例在内存中都有独一无二的的地址。同样空类也会被实例化

### 🏷 C/C++程序内存存储区域

1、**内存栈区**：存放函数参数，函数返回地址，函数内部变量，函数一些寄存器（由编译器自动分配释放）

2、**内存堆区**：存放new或malloc出来的对象（程序员分配释放）

3、**常数区**：存放局部常量和全局常量的值，函数指针

4、**静态区**：存放全局变量或者静态变量，虚函数表

5、**代码区**：二级制代码

c/c++不提供垃圾回收机制，因此需要对堆中的数据进行及时的销毁，防止内存泄漏，使用 `free, delete` 

### 🏷 野指针与悬空指针

野指针：wild pointer没有经过初始化的指针

悬空指针：最初指向的内存已经被释放了的指针

**危害** ：无论是野指针还是悬空指针，都是 *指向无效内存区域的指针*。访问“不安全可控”（invalid）的内存区域 <font color="red">导致“Undefined Behavior</font> 

#### 内存泄漏

简单地说就是申请了一块内存空间，使用完毕后没有释放掉。它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。

由程序申请一块内存，没有指针指向它，那么这块内存就泄漏了

**如何避免内存泄漏**;

1、良好的编码习惯

2、MAT工具监测

### 🏷 new/malloc和free/delete

**首先 new对应的是delete-C++中使用， malloc对应free- c语言使用。free用来释放malloc出来的动态空间，delete用来释放new出来的空间**

**new与malloc区别**

1、new 和malloc都是在堆上开辟内存的

​	malloc只负责开辟内存，没有初始化功能，需要用户自己初始化；new 不但可以开辟内存，还可以进行初始化。

2、malloc是函数，开辟内存需要传入字节数，如 `malloc(100)` 表示在堆上开辟了100个字节的内存，返回void *，表示分配的堆内存的起始位置，因此malloc的返回值需要强制转换为所需类型；new是运算符，开辟的内存需要指定类型，返回指定类型的地址，无需强转

3、 malloc开辟内存失败返回NULL，new 开辟失败返回bad_alloc类型的异常，需要捕获异常才能判断内存是否开辟成功，new 运算符其实operator new 函数的调用，它的底层也是malloc来开辟内存，new它比malloc多的功能就是初始化功能，对应类型来说，就是调用构造函数

4、malloc用free释放，new用delete释放

#### malloc、calloc、realloc、alloca

1、malloc：申请指定字节数内存。申请到的内存中的初始值不确定

2、calloc：为指定长度的对象，分配能够容纳指定个数的内存。申请到的内存的每一bit都初始化为0

3、realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移动另一个足够大的区域，而新增区域内的初始化值则不确定

4、alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca不具备可移植性。

### 🏷 #pragma pack(n)

设定结构体、联合体以及类成员变量以n字节方式对齐

```c++
#pragma pack(push) //保存对齐状态
#pragma pack(4)  //设定为4字节对齐
static test
{
  char m1;
  double m4;
  int m3;
};
#pragma pack(pop)  // 恢复对齐状态 
```



### 🏷 c与C++区别

设计思想上:

C++是面向对象的语言，而C是面向过程的结构化编程语言

语法上：

C++具有封装、继承、多态性

C++与C相比，增加了许多类型安全功能，比如强制类型转换

C++支持范式编程，如模板类，函数模板等

### 🏷 cast转换

C++中四种类型转换： [原文](https://www.jianshu.com/p/5163a2678171)

1、const_cast

格式：`const int b = 0; int * p = const_cast<int* > (&b);`

用于将const变量转为非const

2、static_cast

static_cast的转换格式： `static_cast <type-id> (expression)`

a. 基本数据类型之间的转换，如int 转char

举例：

```c++
short value = 64;
int val = static_cast<int> (value);
// short是2个字节，int是4个字节，将short转成int之后，高位根据符号位补满
```

b. 用于类层次结构中，基类和子类之间的指针和引用的转换

> 当进行上行转换，子类的指针或引用转成父类表示，这是安全的
>
> 当进行下行转换，父类的指针或引用转成子类表示，这是不安全的，需要程序员保证

c. 用于各种隐式转换，比如非const转const, void*转指针等。

3、dynamic_cast

用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上或向下转换。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛出异常

它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行转换

4、reinterpret_cast

几乎什么都可转，比如int转指针

### 🏷 指针与引用

1、指针有自己的一块空间，而引用只是一个别名

2、使用sizeof看，一个指针的大小是4，而引用则是被引用对象的大小

3、指针可以被初始化为NULL，而引用必须被初始化一个已有对象的引用

4、作为参数传递时，指针需要被解引用才可以进行对对象的操作，而直接对引用的修改会改变引用指向的对象；

5、指针在使用中可以指向其他的对象，但是引用只能对一个对象的引用

6、指针可以有多级指针（** p) ，而引用只有一级

7、指针和引用使用++运算符的意义不一样

8、如果返回多态内存分配对象或内存，必须使用指针，引用可能引起内存泄漏

### 🏷 C++中struct和class

总的来说，struct更适合看做一个数据结构的食堂，class更适合看成一个对象的实体

在C++中可以使用struct和class定义类，都可以继承。

区别在于:struct的默认继承权限和默认访问权限是public；

class的默认继承权限和默认访问权限是private

另外， class还可以定义模板类形参，如 `template<class T, int i>`

### 🏷 类成员的访问权限

1、public：类中、类外可以访问

2、protected：子类，以及本类所访问

3、private：成员函数可以访问，友元类或友元函数访问

### 🏷 union联合

union是一种节省空间的特殊的类，一个union可以有多个数据成员，但是对外只表示一个数据成员。当某个数据成员被赋值后其他成员变成未定义状态。联合特点

* 默认访问控制符是public
* 可以包含构造函数、析构函数
* 不能含有引用类型的成员
* 不能继承、和被继承
* 匿名union在定义所在作用域可以直接访问成员
* 不能包含protected和private成员
* 全局匿名联合必须是静态（static）的

```c++
#include<iostream>
union UnionTest{
  UnionTest():i(10){};
  int i;
  double d;
};

static union{
  int i;
  double d;
};
int main()
{
  UnionTest u;
  union {
    int i;
    double d;
  };
  std::cout << u.i << std::endl; // 输出UnionTest的10
  ::i = 20;
  std::cout << ::i << std::endl; //输出全局静态匿名联合20
  i= 30;
  std::cout << i << std::endl;  //30
  return 0;
}
```

### 🏷 友元

友元关系不具有对称性。即A是B的友元，但B不一定是A的友元。友元关系也不具有传递性，即B是A的友元，C是B的友元，但C不一定是A的友元

### 友元函数

特点：友元函数是能够访问类中的私有成员的非成员函数。友元与普通函数一样，即在定义上和调用上与普通函数一样。

```c++
#include<iostream>
#include<cmath>
using namespace std;
class Point
{
  public:
    Point(double xx, double yy)
    {
      x = xx;
      y = yy;
    }
  void Getxy();
  friend double Distance(Point &a, Point &b);
  private:
    double x, y;
};
void Point::Getxy()
{
  cout<<x<<y<<endl;
}
double Distance(Point &a, Point &b)
{
  double dx = a.x - b.x;
  double dy = a.y = b.y;
  return sqrt(dx*dx + dy*dy);
}

int main(void)
{
  Point P1(3.0, 4.0), p2(6.0, 8.0);
  double d = Distance(p1, p2);
  cout << d;
  return 0;
}
```

在该程序中的Point类中声明了一个友元函数Distance()，函数名前加friend关键字。但是他的定义与普通函数是一样的，不需要指出所属类，但是它可以引用类中的私有成员。

#### 友元类

定义：友元除了函数以为，还可以是类，即一个类作为另一个类的友元。当一个类作为另一个类的友元时，这就意味着这个类的所有成员函数都是另一个类的友元函数，都可以访问另一个类的隐藏信息（包括私有成员和保护成员）

### 🏷 using 

**using 声明**：

一条 `using声明` 语句一次只能引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字， 如 `using namespace_name::name`

**构造函数的using声明**

在C++11 中，派生类能够重用其直接基类定义的构造函数

```c++
class Derived::Base
{
  public:
    using Base:base;
};
```

如上using声明，对应基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函。生成如下类型构造函数：

```c++
Derived(parms) : Base(args){}
```

**using指示**

使得某个特定的命名空间中所有名字都可见，这样我们无需再为它们添加任何前缀限定符了。

```c++
using namespace std;
```

尽量少使用using指示污染命名空间

> 一般，使用using命令比使用using编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发送冲突，编译器会发出提示。using编译命令导入所有的名称，包括可能并不使用的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器不会发出警告 。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确地知道添加了哪些名称。

少使用using指示

```c++
using namespace std;
```

多使用using声明

```c++
int x;
std::cin >> x;
```

或者

```c++
using std::cin;
using std::cout;
using std::endl;
int x;
cin >>x;
cout <<x<<endl;
```

### 🏷 :: 范围解析运算符

**分类**

1、全局作用域符(::name)：用于类型名称（类，类成员、成员函数、变量等），表示作用域为全局命名空间

2、类作用域（class::name) : 用于表示指定类作用域范围是具体某个类

3、命名空间作用域符（namespace::name)：用于表示指定类型的作用域范围是具体某个命名空间

```c++
int count = 11;  
class A{
  public: static int count;
};
int A::count = 21;
void fun()
{
  int count = 31;
  count = 32;
}

int main()
{
  cout<<::count;  //11
  A::count;  //21
  return 0;
}
```

### 🏷 enum枚举类型

限定作用域的枚举类型

```c++
enum class ioen{input, output, apppend};
```

不限定作用域的枚举类型

```c++
enum color (red, yellow, green);
enum {floatPrec = 6, doublePrec = 10};
```

### 🏷 decltype

作用于检查实体的声明类型或表达式的类型以及值分类

```c++
//尾置返回允许我们在参数列表之后声明返回类型
template<typename It>
auto fun(It beg, It end)->decltype(*beg)
{
  //处理序列
  return *beg; //返回序列中的一个元素的引用
}
//为了使用模板参数成员必须使用typename
template<typename It>
auto f(It beg, It end)->typename remove_reference<decltype(*beg)>>::type
{
  return *beg;  // 返回一个元素的拷贝
}
```

### 🏷 引用-左值引用-右值引用

右值引用是C++11中引入的新特性，它实现了转移语义和精确传递。它的主要目的有两个方面：

1、消除两个对象交互是不必要的对象拷贝，节省运算存储资源，提高效率

2、能够更简洁明确地定义泛型函数。

右值：当一个对象被当做右值时，用的是对象的内容，**右值要么是字面常量，要么是在表达式求值过程中创建的对象。不能对表达式取地址，或匿名对象。一般指表达式结束就不存在的临时对象**

左值：能对表达式取地址，或具名对象/变量。一般指表达式结束后依然存在的持久对象。

右值引用（&&）

左值引用（&）

```c++
int i = 32;
int &r = i;             //正确，r引用i
int &&rr = i;           //错误，不能将一个右值引用到左值上
int &r2 = i*32;         //错误，i*32是一个右值
const int &r3 = i*32;   //正确，可以将一个const引用绑定到一个右值上
int &&r4 = i*32;       //正确，将r4绑定到右值
```

### 🏷 智能指针

智能指针的作用是管理一个指针，解决因申请空间而忘记释放，造成内存泄漏的问题。

因为智能指针是一个类，当超出类的作用域时，类会自动调用析构函数，释放资源。不需要手动释放

1、auto_ptr(C++98的方案，cpp11弃用)

采用所有权模式。

```c++
auto_ptr<string> p1 (new string ("safasdf"));
auto_ptr<string> p2;
p2 = p1; // 不会报错
```

此时p2剥夺了p1的所有权，但是当程序运行时访问p1会报错。所以存在内存崩溃的问题。

2、unique_ptr（替换auto_ptr)

unique采用独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象，它对于避免资源协议特别有用

```c++
auto_ptr<string> p1 (new string ("safasdf"));
auto_ptr<string> p2;
p2 = p1; // 会报错
```

另外unique_ptr还有更聪明的地方，当程序视图将一个unique_ptr赋值给另一个是，如果员unique_ptr是一个临时右值，则允许这么做。如果原unique_ptr存在一段时间，编译器禁止

```c++  
unique_ptr<string> p1 (new string("adf"));
unique_ptr<string p2;
p2 = p1;   //not allowed
unique_ptr<string> p3;
p3 = unique_ptr<string>(new string("sdf"));   //allowed
```

3、shared_ptr

实现共享式坐拥。多个智能指针可以指向相同对象，该对象和其相关资源会在”最后一个引用被销毁时“释放。它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr, weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数器减一，当计数器等于0时，资源被释放

Share_ptr是为了解决auto_ptr在对象所有权上的局限性

**成员函数**：

use_count返回引用计数个数

unique返回是否独占所有权（use_count=1)

swap交换两个shared_ptr对象

reset释放内部对象的所有权或拥有对象的变更，会引起原有对象的引用计数的减少

get返回内部对象（指针）。

4、weak_ptr

是一个不控制对象生命周期的智能指针。指向一个shared_ptr管理的对象，进行该对象的内存管理的是那个shared_ptr，weak_ptr只是提供对管理对象的一个访问手段。weak_ptr设计的目的是为了配合shared_ptr工作。它只可以从一个shared_ptr或另一个weak_ptr对象构造，它的构造和析构都不会引起计数的变化。

weak_ptr是用来解决shared_ptr相互引用引起的死锁问题。如果两个shared_ptr指针相互引用，那么两个指针的引用计数永不归零，资源永不释放。它是对对象的一种若引用。

```c++
class B;
class A
{
  public:
      shared_ptr<B> pb_;
      ~A();
};
class B
{
  public:
      shared_ptr<A> pa_;
      ~B();
};
void func()
{
  shared_ptr<B> pb(new B());
  shared_ptr<A> pa(new A());
  pb->pa_ = pa;
  pa->pb_ = pb;
}
int main()
{
  fun();
  return 0;
}
```

fun中pa,pb相互引用

### 🏷 函数指针

定义：函数指针是指向函数的指针变量

函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如指针变量可指向整型变量、字符型、数组一样。

C 在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针指向的地址，有了指向函数的指针变量后，可用该指针变量调用函数，就如同指针变量可引用其他类型变量一样。

用途：调用函数和做函数的参数，比如回调函数

示例：

```c++
char *fun(char *p){}  //函数  返回的是一个char *指针
char *(*pf)(char *p); // 函数指针pf
pf = fun;   //函数指针pf指向函数fun
```

### 🏷 面向对象三大特征

#### 封装

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或对象操作，对不可信的进行隐藏

#### 继承

派生类继承基类

#### **多态**

消息以多种形式展现的能力

多态是以封装和继承为基础的

C++多态分类以及实现：

> 1、重载多态（编译期，静态多态）：函数重载，运算符重载
>
> 2、子类型多态（运行期，动态多态）：虚函数
>
> 3、参数多态性（编译期，静态多态）：类模板，函数模板
>
> 4、强制多态（运行期，动态）：基本类型转换，自定义类型转换

### 🏷 不能被继承的类

一个类不能被继承，也就是说它的子类不能构造父类，这样的子类就不能实例化这个子类，从而实现子类无法继承父类

我们可以将一类的构造函数声明为私有，使得这个类的构造函数对子类不可见，那么这个类就不能被继承了。

但是这样也引出了一个问题。客户程序也无法实例化这个类的实例。

**参考单例模式，用一个static函数来帮助创建这个类的实例**

```c++
class Cparent
{
  private:
      Cparent(int v){m_v = v};
  		~Cparent(){};
      int m_v;
      static Cparent *m_instance;
  public:
      static Cparent* getInstance(int v)
      {
        m_instance = new Cparent(v);
        return m_instance;
      }
}
```

### 🏷 析构函数

析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。

析构函数名也对应与 `~类名` 。它不能带任何参数，没有返回值（包括void）。只能有一个析构函数，不能重载。

如果用户没有编写析构函数，编译系统会自动生成一个省缺的析构函数（即使自定义了析构函数，编译器也总会为我们合成一个析构函数，编译器在执行的时候会先调用自定义的析构函数，再调用合成的析构函数），它也不进行任何的操作。许多简单的类中没有用显式的析构函数。

类析构顺序：1）派生类本身的析构函数，2）对象成员的析构函数，3）基类的析构函数。

### 🏷 虚函数virtual、纯虚函数

* 类如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作业就是为了能让这个函数在它的子类可以被覆盖，这样的话，编译器就可以使用后期绑定来达到多态。纯虚函数只是一个接口，是个函数声明而已，它要留到子类去实现。
* 虚函数在子类里可以不重写，但是纯虚函数必须在子类中实现才可以实例化子类
* 虚函数的类用作与”实作继承“，继承接口同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成
* 带有纯虚函数的类叫做抽象类，这种类不能直接生成对象，而且只能被继承，并且需重写其虚函数后，才能使用。
* 虚基类是虚继承中的记录

虚函数使用场景**：

使用一个基类指针指向一个派生类，基类指针只能用基类方法

换句话说，通过基类指针只能访问派生类的成员变量，不能访问派生类的方法

为了消除这种尴尬，让基类指针能够访问派生类的成员数据，C++增加了虚函数

**注意**：

* 带纯虚函数的类不能被实例化

* 构造函数不能是虚构函数，创建派生类的时候要调用派生类的构造函数，派生类的构造函数不能继承基类的构造函数
* 析构函数应该是虚函数，除非类不用做基类，默认的析构函数不能是虚函数
* 友元函数不能是虚函数，因为友元函数不是成员函数

#### 虚函数实现原理

[虚函数实现原理-原文](https://www.cnblogs.com/malecrab/p/5572730.html)                   图片来自原文

每一个含有虚函数（无论是其本身，还是继承而来的）的类都至少有一个与之对应的虚函数表，其存放着该类所有虚函数对应的函数指针。

![pic](https://images2015.cnblogs.com/blog/898333/201606/898333-20160609210402699-1501495771.png)

其中：

* B的虚函数表中存放着B::foo和B::bar两个函数指针。
* D的虚函数表中存放中继承自B的虚函数，还有自己的虚函数

**虚函数的构造过程**

![img](https://images2015.cnblogs.com/blog/898333/201606/898333-20160609210418246-1188626035.png)

**虚函数的调用过程**

![img](https://images2015.cnblogs.com/blog/898333/201606/898333-20160609210434386-1391536209.png)

编译器只知道`pb`是`B*`类型的指针，并不知道它指向的具体对象类型：`pb`可能指向的是`B`的对象，也可能指向的是`D`的对象

但是对于 `pb->bar()` ，编译器能够确定的是：此处 `operator->` 的另外一个参数就是 `B::bar` （因为 `pb`是 `B*` 类型的，编译器认为 `bar` 是 `B::bar`），而`B::bar`和`D::bar`在各自的虚函数表中偏移位置是相等的。

无论`pb`指向哪种类型的对象，只要能够确定被调函数在虚函数中的偏移量，待运行时，就能确定具体类型，并找到相应的`vprt`了，就能调用具体类型，并能找到真正应该调用的函数。

**多重继承**

![img](https://images2015.cnblogs.com/blog/898333/201606/898333-20160609210449511-346261020.png)

其中：D自身的虚函数与B基类共用了一个虚函数表，因此称B为D的主基类。

虚函数替换过程和前面描述的类似，只是多个一个虚函数表，多了一次拷贝和替换的过程

### 🏷 虚继承

虚继承用于解决多继承条件下的菱形继承问题

### 🏷 重载和覆盖

**重载**：两个函数同名，但是参数列表**（参数个数，类型，顺序）**不同，返回值类型没有要求，在同一个作用域中，const修饰的同名函数也算。

> **用处**：用于处理实现功能相似而数据类型不同的问题，减少函数名的数量，避免名字空间的污染，提升可读性

**重写** ：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写

C++中不仅函数可以重载，运算符也可以重载

**❓c语言为什么不能支持函数重载？**

编译器只会对函数进行简单的重命名，不能区分

**❓C++函数重载底层是如何处理的？**

编译器将同名不同参的函数在符号表中生成不同的名字，编译器根据调用者传入的参数类型和个数可以唯一确定调用哪一个函数。

### 🏷 静态函数与虚函数

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次开销内存。

### 🏷 析构函数与虚函数

**❓为什么析构函数必须是虚函数？为什么默认的析构函数不是虚函数？**

1、将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类时，然后使用基类 指针指向该子类对象，释放基类指针可以释放掉子类的空间，防止内存泄漏

2、C++默认的析构函数不是虚函数，是因为虚函数需要额外的虚函数表和虚函数指针，占用额外的内存。而对不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当做父类时，设置为虚函数。

### 函数

**❓C++如何进行函数调用？**

每个函数调用都会分配函数栈，在栈内进行函数执行过程，调用前，先把返回地址压栈，然后把当前函数的esp指针压栈

**❓C++如何处理返回值**

生成一个临时变量，把它的引用作为函数参数传入函数内。

**❓C++中拷贝赋值函数的形参能否进行值传递？**

不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。如此循环，无法完成拷贝，栈也会满。

### 🏷 ❓delete this合法吗？

合法，但

* 必须保证 `this` 对象是通过 `new` 分配的
* 必须保证调用 `delete this` 的成员函数是最后调用`this`的成员函
* 必须保证成员函数的`delete this` 后面没有调用 `this` 了
* 必须保证 `delete this`后面没人使用了

### 🏷 ❓如何定义一个只能在堆上（栈上）生成的对象？

**只能在堆上**

方法：将析构函数设置为私有

原因：C++是静态绑定语言，编译器管理栈上的对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

**只能在栈上**

方法：将new和delete重载为私有

原因：在堆上生成对象，使用new关键字操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将new操作设置为私有，那么第一阶段就无法完成，就不能在堆上生成对象

## 📚STL

《STL源码解析》-侯捷

### 🏷 概述

STL提供六大组件

1、**容器**：各种数据结构， 如vector，list， deque, set， map，用来存放数据；

2、**算法**：各种常见算法如sort，search，copy，erase

3、**迭代器**：扮演容器与算法之间的胶合剂，是所谓的“泛型指针”

4、**仿函数**：行为类似函数，可以作为算法的某种策略

5、**配接器**：一种用来修饰容器或仿函数或迭代器接口的东西

6、**空间配置器**：负责空间配置与管理

### 🏷 空间配置器

[参考](https://blog.csdn.net/md521/article/details/42046043)

STL采用二级配置器结构

**1、第一级配置器**

以malloc(), free(), realloc()等C函数执行实际内存配置、释放、重新配置等操作，若调用malloc(),realloc()不成功，会去循环调用“内存空间不足处理例程”，期望某次调用后获得足够的内存空间而圆满的完成任务，若还是不成功，返回异常

一级空间配置器分配的是大于128字节的内存

如果分配不成功，调用句柄释放一部分内存，若还是分配不成功，抛出异常

**2、二级配置器**

当配置区块超过128B时调用一级配置器；否则采用内存池管理空间分配

工作流程：

当使用二级配置器时，从自由链表维护的内存块中申请内存，若没有对应申请大小的自由链表，则从内存池中申请内存构造自由链表，内存池内存不足时，从堆中申请内存填充内存池（

**自由链表**：复杂维护不同大小的内存块，由于二级配置器会将内存需求量上调为8的倍数，且能够分配的最大内存为128B，则自由链表的个数为16个；每个链表分别维护内存大小为8，16，24，32，48......128的内存空间大小

![img](http://www.xyongs.cn/image/stl_malloc.png)

### 🏷 迭代器

根据STL中的分类，iterator包括：

**输入迭代器**（Input Iterator）：通过对输入迭代器解除引用，它将引用对象，而对象可能位于集合中。最严格的输入迭代只能以只读方式访问对象。例如：istream。 

**输出迭代器**（Output Iterator）：该类迭代器和Input Iterator极其相似，也只能单步向前迭代元素，不同的是该类迭代器对元素只有写的权力。例如：ostream, inserter。 

以上两种基本迭代器可进一步分为三类：

**前向迭代器**（Forward Iterator）：该类迭代器可以在一个正确的区间中进行读写操作，它拥有Input Iterator的所有特性，和Output Iterator的部分特性，以及单步向前迭代元素的能力。

**双向迭代器**（Bidirectional Iterator）：该类迭代器是在Forward Iterator的基础上提供了单步向后迭代元素的能力。例如：list, set, multiset, map, multimap。

**随机迭代器**（Random Access Iterator）：该类迭代器能完成上面所有迭代器的工作，它自己独有的特性就是可以像指针那样进行算术计算，而不是仅仅只有单步向前或向后迭代。例如：vector, deque, string, array。 

**1 Input Iterators**

Input Iterator只能逐元素的向前遍历，而且对元素是只读的，只能读取元素一次。通常这种情况发生在从标准输入设备（通常是键盘）读取数据时。

下面是Input Iterator的可用操作列表：

*iter: 只读访问对应的元素 

iter->member: 只读访问对应元素的成员 

++iter: 向前遍历一步（返回最新的位置) 

iter++: 向前遍历一步（返回原先的位置） 

iter1 == iter2: 判断两个迭代器是否相等 

iter1 != iter2：判断两个迭代器是否不等 

TYPE(iter): 复制迭代器 

**2 Output Iterators**

Output iterator跟Input Iterator相对应，只能逐元素向前遍历，而且对元素是只写的(*iter操作不能作为右值，只能作为左值)，只能写入元素一次。通常这种情况发生在向标准输出设备(屏幕或者打印机)写入数据时，或者利用inserter向容器中追加新元素时。

3 Forward Iterators

Forward Iterator是Input Iterator和Output Iterator的结合，虽然也只能逐元素向前遍历，但可以对元素进行读写操作。下面看Forward Iterator的可用操作列表：

4 Bidirectional Iterators

双向迭代器行为特征类似于Forward Iterator，只是额外增加了一个逐元素向后遍历的能力。所以对于双向迭代器可用的操作，除了包含Forward Iterator的所有操作外，多了一组向后遍历的操作：

5 Random Access Iterators

随机访问迭代器除了有双向迭代器的能力特征外，还可以进行元素随机访问。所以对于随机访问迭代器，增加了关于“迭代器运算”的一些操作。下面是除了双向迭代器的所有操作外，额外的操作列表：

### 🏷 序列式容器

#### vector

存储连续的线性空间

1、**迭代器**：Random Access Iterators。

vector维护一个连续线性空间，支持随机存取。

2、**构造与内存管理**

![image](http://www.xyongs.cn/image/vector.png)

当我们以push_back()将新元素插入vector尾端时，该函数首先检查是否还有备用空间，若有直接在备用空间中构造元素，并调整迭代器，若没有就扩充空间（重新配置、移动元素、释放原空间）

vector是动态增加大小的，它以原来大小的两倍配置一个较大的空间，然后将原内容拷贝过来，然后在开始在原内容中构造新元素，并释放原空间。

3、**操作**

| 方法                        | 含义                           |
| --------------------------- | ------------------------------ |
| pop_back()                  | 将尾端元素拿掉，并调整大小     |
| resize()                    | 调整容器大小                   |
| capacity                    | 返回当前为vector分配的容量大小 |
| reserve(i.begin(), i.end()) | 反转vector                     |
| erase(it)                   | 删除某个位置上的元素           |
| insert(pos, n,x)            | pos位置插入n个x元素            |

#### list

保存线性空间，每次插入或删除一个元素就配置或释放一个空间。

1、**迭代器**

Bidirectional Iterators

list是一个双向链表，迭代器必须具备前移、后移能力

2、**构成与内存管理**

每次插入或删除一个元素就配置或释放一个空间，对于任何位置的插入或删除操作都是常数时间。

3、**操作**

| 方法                | 含义                                                     |
| ------------------- | -------------------------------------------------------- |
| push_front(it)      | 头结点插入元素                                           |
| push_back(it)       | 尾结点插入                                               |
| erase(it)           | 删除                                                     |
| pop_front()         |                                                          |
| Pop_back()          |                                                          |
| clear()             |                                                          |
| remove(val)         | 将数值为val所有元素移除                                  |
| unique()            | 移除数值相同的连续元素，只有连续而相同的元素才会移除一个 |
| transfer(pos, f, l) | 将[f,l) 内的元素移动到pos之前                            |
| splice(pos,x)       | 将x接合与pos所指位置之前                                 |
| merge(list &x)      | x 合并到*this上，前提：两者得有序                        |
| find(f, e, 99)      | [f,e)范围内查找99                                        |



#### deque

#### stack

#### queue

#### heap

#### priority_queue