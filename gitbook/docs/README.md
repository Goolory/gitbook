## 📚C++

### 🏷const 关键字

**作用**

1、修饰变量，说明该变量不可以被改变

2、修饰指针，分为指向常量的指针（pointer to const 如：const int * p ）const在 * 之前，不能通过 * P来修改所指向的内容去的内容；常量指针，简称常指针：int * const p, * 在const之前，不能改变指向的位置

```c++
char g[] = "hello";
const char* p1 = g;  //指针变量，不能通过*p1 改变内容，可以改变位置
char * const p2 = g;  //常量指针，不能改变指针指向的位置；可以改变内容
```

3、修饰引用，指向常量的应用，用于形参类型，避免了拷贝，又避免了函数对值得修改；

```c++
void function(const int& var);
```

4、修饰成员函数，该成员函数内不能改变成员变量。

```c++
class A{
 int func() const; 
}
```

### 🏷 static关键字

| static作用       | 存储区 | 初始化     | 作用域                                                   | 备注                                                         |
| ---------------- | ------ | ---------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 定义全局静态变量 | 静态区 | 默认初始化 | 仅在声明它的文件中可见，不被其他文件所用                 | 在main函数执行前就分配了空间                                 |
| 局部静态变量     | 静态区 | 默认初始化 | 局部作用域                                               | 当执行离开局部作用域后，该变量没有被销毁，任然驻留在内存中。 |
| 静态函数         |        |            | 仅在声明它的文件中可见，不被其他文件所用                 | 不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果要在多个cpp中重复使用该函数，就把它声明到头文件中，否则cpp内部声明应该加上static修饰 |
| 类的静态成员     |        |            |                                                          | 静态成员是类的所有对象中共享的成员，而不是某个对象的成员，对多个成员来说，静态数据成员只存储一处，对所有对象共用。 |
| 类的静态函数     |        |            | 静态函数与静态成员一样，不是对象成员，引用时不需要对象名 | 引用格式：<类名>::<静态成员函数名>(<参数>);                  |

### 🏷 extern关键字

1、可以置于变量或者函数前，以声明变量或者函数的定义在别的文件中，提示编译器在遇到次变量和函数时在其他模块中寻找其定义

2、链接指定，当他和"C"一起连用时，`extern "c" void fun(int a, int b)`;这 告诉编译器在编译这个fun按照c的规则去翻译函数名

与include相比，extern引用另一个文件的范围小，include可以引用另一个文件的全部内容

### 🏷 explicit关键字

C++中的explicit关键字只能修饰只有一个参数的类构造函数，作用是表名该构造函数是显示的，而非隐式的，跟它对应的另一关键字是implicit，意思是隐藏的，类的构造函数默认下即声明为implicit

参考https://blog.csdn.net/guoyunfei123/article/details/89003369

### 🏷this指针

1、`this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象

2、当对一个对象调用成员函数时，编译程序先将对象的地址赋值给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式的使用 `this` 指针。

3、当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数指向这个成员函数所在对象的指针。

4、`this` 指针被隐含的声明为： `ClassName *const this` ,这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员中， `this` 指针的类型为 `const ClassName* const` ,这说明不能对 `this` 指针所指向的这种对象是不可修改的

5、 `this` 并不是常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this` )

6、在以下场景中，经常需要显示的应用 `this` 指针：

​	1、为实现对象的链式引用；

​	2、为了避免对同一对象进行赋值操作；

​	3、实现一些数据结构时，

### 🏷 inline 内联函数

* 相当于把内联函数里的内容写在调用内联函数处
* 相当于不用执行进入函数的步骤，直接执行函数体；
* 相当于宏，却比宏多了类型检查，真正具有函数特性；
* 内联一般不包含循环、递归等复杂操作
* 在类声明中定义的函数，除了虚函数其他函数都会自动隐式地当成内联函数。

