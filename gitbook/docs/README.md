## 📚C++

### 🏷const

**作用**

1、修饰变量，说明该变量不可以被改变

2、修饰指针，分为指向常量的指针（pointer to const 如：const int * p ）const在 * 之前，不能通过 * P来修改所指向的内容去的内容；常量指针，简称常指针：int * const p, * 在const之前，不能改变指向的位置

```c++
char g[] = "hello";
const char* p1 = g;  //指针变量，不能通过*p1 改变内容，可以改变位置
char * const p2 = g;  //常量指针，不能改变指针指向的位置；可以改变内容
```

3、修饰引用，指向常量的应用，用于形参类型，避免了拷贝，又避免了函数对值得修改；

```c++
void function(const int& var);
```

4、修饰成员函数，该成员函数内不能改变成员变量。

```c++
class A{
 int func() const; 
}
```

### 🏷 static

| static作用       | 存储区 | 初始化     | 作用域                                                       | 备注                                                         |
| ---------------- | ------ | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义全局静态变量 | 静态区 | 默认初始化 | 仅在声明它的文件中可见，不被其他文件所用                     | 在main函数执行前就分配了空间                                 |
| 局部静态变量     | 静态区 | 默认初始化 | 局部作用域                                                   | 当执行离开局部作用域后，该变量没有被销毁，任然驻留在内存中。 |
| 静态函数         |        |            | 仅在声明它的文件中可见，不被其他文件所用                     | 不要在头文件中声明static的全局函数，<br />不要在cpp内声明非static的全局函数.<br />如果要在多个cpp中重复使用该函数，就把它声明到头文件中<br />否则cpp内部声明应该加上static修饰 |
| 类的静态成员     |        |            |                                                              | 静态成员是类的所有对象中共享的成员，而不是某个对象的成员.<br />静态数据成员只存储一处，对所有对象共用。 |
| 类的静态函数     |        |            | 静态函数与静态成员一样，<br />不是对象成员，引用时不需要对象名 | 引用格式：<类名>::<静态成员函数名>(<参数>);                  |

### 🏷 extern

1、可以置于变量或者函数前，以声明变量或者函数的定义在别的文件中，提示编译器在遇到次变量和函数时在其他模块中寻找其定义

2、链接指定，当他和"C"一起连用时，`extern "c" void fun(int a, int b)`;这 告诉编译器在编译这个fun按照c的规则去翻译函数名

与include相比，extern引用另一个文件的范围小，include可以引用另一个文件的全部内容

### 🏷 explicit关键字

C++中的explicit关键字只能修饰只有一个参数的类构造函数，作用是表名该构造函数是显示的，而非隐式的，跟它对应的另一关键字是implicit，意思是隐藏的，类的构造函数默认下即声明为implicit

参考https://blog.csdn.net/guoyunfei123/article/details/89003369

### 🏷this指针

1、`this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象

2、当对一个对象调用成员函数时，编译程序先将对象的地址赋值给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式的使用 `this` 指针。

3、当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数指向这个成员函数所在对象的指针。

4、`this` 指针被隐含的声明为： `ClassName *const this` ,这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员中， `this` 指针的类型为 `const ClassName* const` ,这说明不能对 `this` 指针所指向的这种对象是不可修改的

5、 `this` 并不是常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this` )

6、在以下场景中，经常需要显示的应用 `this` 指针：

​	1、为实现对象的链式引用；

​	2、为了避免对同一对象进行赋值操作；

​	3、实现一些数据结构时，

### 🏷 inline 内联函数

* 相当于把内联函数里的内容写在调用内联函数处
* 相当于不用执行进入函数的步骤，直接执行函数体；
* 相当于宏，却比宏多了类型检查，真正具有函数特性；
* 内联一般不包含循环、递归等复杂操作
* 在类声明中定义的函数，除了虚函数其他函数都会自动隐式地当成内联函数。

####  编译器对inline函数的处理步骤

1、将inline函数体复制到inline函数调用点处；

2、为所用inline函数中的局部变量分配内存空间；

3、将inline函数的输入参数和返回值映射到调用方法的局部变量空间中；

4、如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支（使GOTO）

#### 优缺点

**优点**

1、内联函数和宏函数一样将在被调用处进行代码展开，省去了参数压栈，栈帧开辟与回收，结果返回等，从而提高程序的运行速度；

2、内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换，而宏定义不会；

3、在类中声明的同时定义的成员函数，会自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义不行

4、内联函数在运行时可以调试，而宏定义不可以

**缺点**

1、代码膨胀💥。内联是一代码膨胀为代价，消除函数调用带来的开销。

2、inline函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不行on-inline可以直接链接

#### 虚函数（virtual）可以是内联函数吗？

* 虚函数可以是内联函数，内联可以修饰虚函数的，但是当虚函数表现多态性时不能内联
* 内联是在编译期内联，而虚函数的多态性是在运行期。编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时不可内联。
*  `inline virtual`  唯一内联的时候是：编译器知道调用的对象是哪个类 （如 `Base::who()` ,这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

``` c++
#include<iostream>
using namespace std;
class Base
{
  public:
    inline virtual void who()
    {
      cout << "kkk\n";
    }
    virtual ~Base(){}
};
class Derived : public Base
{
  public:
    inline void who()  // 不写inline时隐式内联
    {
      cout << "kkk";
    }
};
int main()
{
  Base b;
  b.who();  // 此处的虚函数是who()，是通过类Base的具体对象b来调用，编译器就能确定了
  
  // 此处的虚函数是通过指针调用的，呈多态性，需要在运行时期才能确定，所以不能内联
  Base* ptr = new Derived();
  ptr->who();
  return 0;
}
```



### 🏷 C/C++程序内存存储区域

1、**内存栈区**：存放函数参数，函数返回地址，函数内部变量，函数一些寄存器（由编译器自动分配释放）

2、**内存堆区**：存放new或malloc出来的对象（程序员分配释放）

3、**常数区**：存放局部常量和全局常量的值，函数指针

4、**静态区**：存放全局变量或者静态变量，虚函数表

5、**代码区**：二级制代码

c/c++不提供垃圾回收机制，因此需要对堆中的数据进行及时的销毁，防止内存泄漏，使用 `free, delete` 

### 🏷 野指针与悬空指针

野指针：wild pointer没有经过初始化的指针

悬空指针：最初指向的内存已经被释放了的指针

**危害** ：无论是野指针还是悬空指针，都是 *指向无效内存区域的指针*。访问“不安全可控”（invalid）的内存区域 <font color="red">导致“Undefined Behavior</font> 

#### 内存泄漏

简单地说就是申请了一块内存空间，使用完毕后没有释放掉。它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。

由程序申请一块内存，没有指针指向它，那么这块内存就泄漏了

**如何避免内存泄漏**;

1、良好的编码习惯

2、MAT工具监测

### 🏷 new/malloc和free/delete

**首先 new对应的是delete-C++中使用， malloc对应free- c语言使用。free用来释放malloc出来的动态空间，delete用来释放new出来的空间**

**new与malloc区别**



