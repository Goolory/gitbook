## 📚C++

### 🏷const

**作用**

1、修饰变量，说明该变量不可以被改变

2、修饰指针，分为指向常量的指针（pointer to const 如：const int * p ）const在 * 之前，不能通过 * P来修改所指向的内容去的内容；常量指针，简称常指针：int * const p, * 在const之前，不能改变指向的位置

```c++
char g[] = "hello";
const char* p1 = g;  //指针变量，不能通过*p1 改变内容，可以改变位置
char * const p2 = g;  //常量指针，不能改变指针指向的位置；可以改变内容
```

3、修饰引用，指向常量的应用，用于形参类型，避免了拷贝，又避免了函数对值得修改；

```c++
void function(const int& var);
```

4、修饰成员函数，该成员函数内不能改变成员变量。

```c++
class A{
 int func() const; 
}
```

### 🏷 static

| static作用       | 存储区 | 初始化     | 作用域                                                       | 备注                                                         |
| ---------------- | ------ | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义全局静态变量 | 静态区 | 默认初始化 | 仅在声明它的文件中可见，不被其他文件所用                     | 在main函数执行前就分配了空间                                 |
| 局部静态变量     | 静态区 | 默认初始化 | 局部作用域                                                   | 当执行离开局部作用域后，该变量没有被销毁，任然驻留在内存中。 |
| 静态函数         |        |            | 仅在声明它的文件中可见，不被其他文件所用                     | 不要在头文件中声明static的全局函数，<br />不要在cpp内声明非static的全局函数.<br />如果要在多个cpp中重复使用该函数，就把它声明到头文件中<br />否则cpp内部声明应该加上static修饰 |
| 类的静态成员     |        |            |                                                              | 静态成员是类的所有对象中共享的成员，而不是某个对象的成员.<br />静态数据成员只存储一处，对所有对象共用。 |
| 类的静态函数     |        |            | 静态函数与静态成员一样，<br />不是对象成员，引用时不需要对象名 | 引用格式：<类名>::<静态成员函数名>(<参数>);                  |

### 🏷 extern

1、可以置于变量或者函数前，以声明变量或者函数的定义在别的文件中，提示编译器在遇到次变量和函数时在其他模块中寻找其定义

2、链接指定，当他和"C"一起连用时，`extern "c" void fun(int a, int b)`;这 告诉编译器在编译这个fun按照c的规则去翻译函数名

与include相比，extern引用另一个文件的范围小，include可以引用另一个文件的全部内容

### 🏷 explicit关键字

C++中的explicit关键字只能修饰只有一个参数的类构造函数，作用是表名该构造函数是显示的，而非隐式的，跟它对应的另一关键字是implicit，意思是隐藏的，类的构造函数默认下即声明为implicit

参考https://blog.csdn.net/guoyunfei123/article/details/89003369

### 🏷this指针

1、`this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象

2、当对一个对象调用成员函数时，编译程序先将对象的地址赋值给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式的使用 `this` 指针。

3、当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数指向这个成员函数所在对象的指针。

4、`this` 指针被隐含的声明为： `ClassName *const this` ,这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员中， `this` 指针的类型为 `const ClassName* const` ,这说明不能对 `this` 指针所指向的这种对象是不可修改的

5、 `this` 并不是常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this` )

6、在以下场景中，经常需要显示的应用 `this` 指针：

​	1、为实现对象的链式引用；

​	2、为了避免对同一对象进行赋值操作；

​	3、实现一些数据结构时，如：list

### 🏷 inline 内联函数

* 相当于把内联函数里的内容写在调用内联函数处
* 相当于不用执行进入函数的步骤，直接执行函数体；
* 相当于宏，却比宏多了类型检查，真正具有函数特性；
* 内联一般不包含循环、递归等复杂操作
* 在类声明中定义的函数，除了虚函数其他函数都会自动隐式地当成内联函数。

####  编译器对inline函数的处理步骤

1、将inline函数体复制到inline函数调用点处；

2、为所用inline函数中的局部变量分配内存空间；

3、将inline函数的输入参数和返回值映射到调用方法的局部变量空间中；

4、如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支（使GOTO）

#### 优缺点

**优点**

1、内联函数和宏函数一样将在被调用处进行代码展开，省去了参数压栈，栈帧开辟与回收，结果返回等，从而提高程序的运行速度；

2、内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换，而宏定义不会；

3、在类中声明的同时定义的成员函数，会自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义不行

4、内联函数在运行时可以调试，而宏定义不可以

**缺点**

1、代码膨胀💥。内联是一代码膨胀为代价，消除函数调用带来的开销。

2、inline函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不行on-inline可以直接链接

#### 虚函数（virtual）可以是内联函数吗？

* 虚函数可以是内联函数，内联可以修饰虚函数的，但是当虚函数表现多态性时不能内联
* 内联是在编译期内联，而虚函数的多态性是在运行期。编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时不可内联。
*  `inline virtual`  唯一内联的时候是：编译器知道调用的对象是哪个类 （如 `Base::who()` ,这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

``` c++
#include<iostream>
using namespace std;
class Base
{
  public:
    inline virtual void who()
    {
      cout << "kkk\n";
    }
    virtual ~Base(){}
};
class Derived : public Base
{
  public:
    inline void who()  // 不写inline时隐式内联
    {
      cout << "kkk";
    }
};
int main()
{
  Base b;
  b.who();  // 此处的虚函数是who()，是通过类Base的具体对象b来调用，编译器就能确定了
  
  // 此处的虚函数是通过指针调用的，呈多态性，需要在运行时期才能确定，所以不能内联
  Base* ptr = new Derived();
  ptr->who();
  return 0;
}
```

### 🏷 assert()

断言，是宏，而非函数。assert宏的原型定义在 `<assert.h>` c语言 -- `<cassert>` C++

 作用：如果他的条件返回错误，则终止程序执行。可以通过定义 `NOEBUG` 来关闭，需要定义在 `include<assert.h>`  之前 

```c++
#define NDEBUG
#include<assert.h>
assert(p != nullptr);
```

### 🏷 sizeof()

* sizeof对数组，得到整个数组占空间大小

* sizeof对指针，得到指针本身大小

  ​	sizefof(空类) = 1；[类的大小——sizeof 的研究(1)](https://www.jianshu.com/p/5163a2678171)

  ​	因为一个空类也要实例化，所谓类的实例化就是在内存中分配一块地址，每个实例在内存中都有独一无二的的地址。同样空类也会被实例化

### 🏷 C/C++程序内存存储区域

1、**内存栈区**：存放函数参数，函数返回地址，函数内部变量，函数一些寄存器（由编译器自动分配释放）

2、**内存堆区**：存放new或malloc出来的对象（程序员分配释放）

3、**常数区**：存放局部常量和全局常量的值，函数指针

4、**静态区**：存放全局变量或者静态变量，虚函数表

5、**代码区**：二级制代码

c/c++不提供垃圾回收机制，因此需要对堆中的数据进行及时的销毁，防止内存泄漏，使用 `free, delete` 

### 🏷 野指针与悬空指针

野指针：wild pointer没有经过初始化的指针

悬空指针：最初指向的内存已经被释放了的指针

**危害** ：无论是野指针还是悬空指针，都是 *指向无效内存区域的指针*。访问“不安全可控”（invalid）的内存区域 <font color="red">导致“Undefined Behavior</font> 

#### 内存泄漏

简单地说就是申请了一块内存空间，使用完毕后没有释放掉。它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。

由程序申请一块内存，没有指针指向它，那么这块内存就泄漏了

**如何避免内存泄漏**;

1、良好的编码习惯

2、MAT工具监测

### 🏷 new/malloc和free/delete

**首先 new对应的是delete-C++中使用， malloc对应free- c语言使用。free用来释放malloc出来的动态空间，delete用来释放new出来的空间**

**new与malloc区别**

1、new 和malloc都是在堆上开辟内存的

​	malloc只负责开辟内存，没有初始化功能，需要用户自己初始化；new 不但可以开辟内存，还可以进行初始化。

2、malloc是函数，开辟内存需要传入字节数，如 `malloc(100)` 表示在堆上开辟了100个字节的内存，返回void *，表示分配的堆内存的起始位置，因此malloc的返回值需要强制转换为所需类型；new是运算符，开辟的内存需要指定类型，返回指定类型的地址，无需强转

3、 malloc开辟内存失败返回NULL，new 开辟失败返回bad_alloc类型的异常，需要捕获异常才能判断内存是否开辟成功，new 运算符其实operator new 函数的调用，它的底层也是malloc来开辟内存，new它比malloc多的功能就是初始化功能，对应类型来说，就是调用构造函数

4、malloc用free释放，new用delete释放

#### malloc、calloc、realloc、alloca

1、malloc：申请指定字节数内存。申请到的内存中的初始值不确定

2、calloc：为指定长度的对象，分配能够容纳指定个数的内存。申请到的内存的每一bit都初始化为0

3、realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移动另一个足够大的区域，而新增区域内的初始化值则不确定

4、alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca不具备可移植性。

### 🏷 #pragma pack(n)

设定结构体、联合体以及类成员变量以n字节方式对齐

```c++
#pragma pack(push) //保存对齐状态
#pragma pack(4)  //设定为4字节对齐
static test
{
  char m1;
  double m4;
  int m3;
};
#pragma pack(pop)  // 恢复对齐状态 
```

### 🏷 c与C++区别

设计思想上:

C++是面向对象的语言，而C是面向过程的结构化编程语言

语法上：

C++具有封装、继承、多态性

C++与C相比，增加了许多类型安全功能，比如强制类型转换

C++支持范式编程，如模板类，函数模板等

### 🏷 cast转换

C++中四种类型转换： [原文](https://www.jianshu.com/p/5163a2678171)

1、const_cast

格式：`const int b = 0; int * p = const_cast<int* > (&b);`

用于将const变量转为非const

2、static_cast

static_cast的转换格式： `static_cast <type-id> (expression)`

a. 基本数据类型之间的转换，如int 转char

举例：

```c++
short value = 64;
int val = static_cast<int> (value);
// short是2个字节，int是4个字节，将short转成int之后，高位根据符号位补满
```

b. 用于类层次结构中，基类和子类之间的指针和引用的转换

> 当进行上行转换，子类的指针或引用转成父类表示，这是安全的
>
> 当进行下行转换，父类的指针或引用转成子类表示，这是不安全的，需要程序员保证

c. 用于各种隐式转换，比如非const转const, void*转指针等。

3、dynamic_cast

用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上或向下转换。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛出异常

它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行转换

4、reinterpret_cast

几乎什么都可转，比如int转指针

### 🏷 指针与引用

1、指针有自己的一块空间，而引用只是一个别名

2、使用sizeof看，一个指针的大小是4，而引用则是被引用对象的大小

3、指针可以被初始化为NULL，而引用必须被初始化一个已有对象的引用

4、作为参数传递时，指针需要被解引用才可以进行对对象的操作，而直接对引用的修改会改变引用指向的对象；

5、指针在使用中可以指向其他的对象，但是引用只能对一个对象的引用

6、指针可以有多级指针（** p) ，而引用只有一级

7、指针和引用使用++运算符的意义不一样

8、如果返回多态内存分配对象或内存，必须使用指针，引用可能引起内存泄漏

### 🏷 C++中struct和class

总的来说，struct更适合看做一个数据结构的食堂，class更适合看成一个对象的实体

在C++中可以使用struct和class定义类，都可以继承。

区别在于:struct的默认继承权限和默认访问权限是public；

class的默认继承权限和默认访问权限是private

另外， class还可以定义模板类形参，如 `template<class T, int i>`

### 🏷 类成员的访问权限

1、public：类中、类外可以访问

2、protected：子类，以及本类所访问

3、private：成员函数可以访问，友元类或友元函数访问

### 🏷 union联合

union是一种节省空间的特殊的类，一个union可以有多个数据成员，但是对外只表示一个数据成员。当某个数据成员被赋值后其他成员变成未定义状态。联合特点

* 默认访问控制符是public
* 可以包含构造函数、析构函数
* 不能含有引用类型的成员
* 不能继承、和被继承
* 匿名union在定义所在作用域可以直接访问成员
* 不能包含protected和private成员
* 全局匿名联合必须是静态（static）的

```c++
#include<iostream>
union UnionTest{
  UnionTest():i(10){};
  int i;
  double d;
};

static union{
  int i;
  double d;
};
int main()
{
  UnionTest u;
  union {
    int i;
    double d;
  };
  std::cout << u.i << std::endl; // 输出UnionTest的10
  ::i = 20;
  std::cout << ::i << std::endl; //输出全局静态匿名联合20
  i= 30;
  std::cout << i << std::endl;  //30
  return 0;
}
```

### 🏷 友元

友元关系不具有对称性。即A是B的友元，但B不一定是A的友元。友元关系也不具有传递性，即B是A的友元，C是B的友元，但C不一定是A的友元

#### 友元函数

特点：友元函数是能够访问类中的私有成员的非成员函数。友元与普通函数一样，即在定义上和调用上与普通函数一样。

```c++
#include<iostream>
#include<cmath>
using namespace std;
class Point
{
  public:
    Point(double xx, double yy)
    {
      x = xx;
      y = yy;
    }
  void Getxy();
  friend double Distance(Point &a, Point &b);
  private:
    double x, y;
};
void Point::Getxy()
{
  cout<<x<<y<<endl;
}
double Distance(Point &a, Point &b)
{
  double dx = a.x - b.x;
  double dy = a.y = b.y;
  return sqrt(dx*dx + dy*dy);
}

int main(void)
{
  Point P1(3.0, 4.0), p2(6.0, 8.0);
  double d = Distance(p1, p2);
  cout << d;
  return 0;
}
```

在该程序中的Point类中声明了一个友元函数Distance()，函数名前加friend关键字。但是他的定义与普通函数是一样的，不需要指出所属类，但是它可以引用类中的私有成员。

#### 友元类

定义：友元除了函数以为，还可以是类，即一个类作为另一个类的友元。当一个类作为另一个类的友元时，这就意味着这个类的所有成员函数都是另一个类的友元函数，都可以访问另一个类的隐藏信息（包括私有成员和保护成员）

### 🏷 using 

**using 声明**：

一条 `using声明` 语句一次只能引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字， 如 `using namespace_name::name`

**构造函数的using声明**

在C++11 中，派生类能够重用其直接基类定义的构造函数

```c++
class Derived::Base
{
  public:
    using Base:base;
};
```

如上using声明，对应基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函。生成如下类型构造函数：

```c++
Derived(parms) : Base(args){}
```

**using指示**

使得某个特定的命名空间中所有名字都可见，这样我们无需再为它们添加任何前缀限定符了。

```c++
using namespace std;
```

尽量少使用using指示污染命名空间

> 一般，使用using命令比使用using编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发送冲突，编译器会发出提示。using编译命令导入所有的名称，包括可能并不使用的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器不会发出警告 。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确地知道添加了哪些名称。

少使用using指示

```c++
using namespace std;
```

多使用using声明

```c++
int x;
std::cin >> x;
```

或者

```c++
using std::cin;
using std::cout;
using std::endl;
int x;
cin >>x;
cout <<x<<endl;
```

### 🏷 :: 范围解析运算符

**分类**

1、全局作用域符(::name)：用于类型名称（类，类成员、成员函数、变量等），表示作用域为全局命名空间

2、类作用域（class::name) : 用于表示指定类作用域范围是具体某个类

3、命名空间作用域符（namespace::name)：用于表示指定类型的作用域范围是具体某个命名空间

```c++
int count = 11;  
class A{
  public: static int count;
};
int A::count = 21;
void fun()
{
  int count = 31;
  count = 32;
}

int main()
{
  cout<<::count;  //11
  A::count;  //21
  return 0;
}
```

### 🏷 enum枚举类型

限定作用域的枚举类型

```c++
enum class ioen{input, output, apppend};
```

不限定作用域的枚举类型

```c++
enum color (red, yellow, green);
enum {floatPrec = 6, doublePrec = 10};
```

### 🏷 decltype

作用于检查实体的声明类型或表达式的类型以及值分类

```c++
//尾置返回允许我们在参数列表之后声明返回类型
template<typename It>
auto fun(It beg, It end)->decltype(*beg)
{
  //处理序列
  return *beg; //返回序列中的一个元素的引用
}
//为了使用模板参数成员必须使用typename
template<typename It>
auto f(It beg, It end)->typename remove_reference<decltype(*beg)>>::type
{
  return *beg;  // 返回一个元素的拷贝
}
```

### 🏷 引用-左值引用-右值引用

右值引用是C++11中引入的新特性，它实现了转移语义和精确传递。它的主要目的有两个方面：

1、消除两个对象交互是不必要的对象拷贝，节省运算存储资源，提高效率

2、能够更简洁明确地定义泛型函数。

右值：当一个对象被当做右值时，用的是对象的内容，**右值要么是字面常量，要么是在表达式求值过程中创建的对象。不能对表达式取地址，或匿名对象。一般指表达式结束就不存在的临时对象**

左值：能对表达式取地址，或具名对象/变量。一般指表达式结束后依然存在的持久对象。

右值引用（&&）

左值引用（&）

```c++
int i = 32;
int &r = i;             //正确，r引用i
int &&rr = i;           //错误，不能将一个右值引用到左值上
int &r2 = i*32;         //错误，i*32是一个右值
const int &r3 = i*32;   //正确，可以将一个const引用绑定到一个右值上
int &&r4 = i*32;       //正确，将r4绑定到右值
```

### 🏷 智能指针

智能指针的作用是管理一个指针，解决因申请空间而忘记释放，造成内存泄漏的问题。

因为智能指针是一个类，当超出类的作用域时，类会自动调用析构函数，释放资源。不需要手动释放

1、auto_ptr(C++98的方案，cpp11弃用)

采用所有权模式。

```c++
auto_ptr<string> p1 (new string ("safasdf"));
auto_ptr<string> p2;
p2 = p1; // 不会报错
```

此时p2剥夺了p1的所有权，但是当程序运行时访问p1会报错。所以存在内存崩溃的问题。

2、unique_ptr（替换auto_ptr)

unique采用独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象，它对于避免资源协议特别有用

```c++
auto_ptr<string> p1 (new string ("safasdf"));
auto_ptr<string> p2;
p2 = p1; // 会报错
```

另外unique_ptr还有更聪明的地方，当程序视图将一个unique_ptr赋值给另一个是，如果员unique_ptr是一个临时右值，则允许这么做。如果原unique_ptr存在一段时间，编译器禁止

```c++  
unique_ptr<string> p1 (new string("adf"));
unique_ptr<string p2;
p2 = p1;   //not allowed
unique_ptr<string> p3;
p3 = unique_ptr<string>(new string("sdf"));   //allowed
```

3、shared_ptr

实现共享式坐拥。多个智能指针可以指向相同对象，该对象和其相关资源会在”最后一个引用被销毁时“释放。它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr, weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数器减一，当计数器等于0时，资源被释放

Share_ptr是为了解决auto_ptr在对象所有权上的局限性

**成员函数**：

use_count返回引用计数个数

unique返回是否独占所有权（use_count=1)

swap交换两个shared_ptr对象

reset释放内部对象的所有权或拥有对象的变更，会引起原有对象的引用计数的减少

get返回内部对象（指针）。

4、weak_ptr

是一个不控制对象生命周期的智能指针。指向一个shared_ptr管理的对象，进行该对象的内存管理的是那个shared_ptr，weak_ptr只是提供对管理对象的一个访问手段。weak_ptr设计的目的是为了配合shared_ptr工作。它只可以从一个shared_ptr或另一个weak_ptr对象构造，它的构造和析构都不会引起计数的变化。

weak_ptr是用来解决shared_ptr相互引用引起的死锁问题。如果两个shared_ptr指针相互引用，那么两个指针的引用计数永不归零，资源永不释放。它是对对象的一种若引用。

```c++
class B;
class A
{
  public:
      shared_ptr<B> pb_;
      ~A();
};
class B
{
  public:
      shared_ptr<A> pa_;
      ~B();
};
void func()
{
  shared_ptr<B> pb(new B());
  shared_ptr<A> pa(new A());
  pb->pa_ = pa;
  pa->pb_ = pb;
}
int main()
{
  fun();
  return 0;
}
```

fun中pa,pb相互引用

### 🏷 函数指针

定义：函数指针是指向函数的指针变量

函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如指针变量可指向整型变量、字符型、数组一样。

C 在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针指向的地址，有了指向函数的指针变量后，可用该指针变量调用函数，就如同指针变量可引用其他类型变量一样。

用途：调用函数和做函数的参数，比如回调函数

示例：

```c++
char *fun(char *p){}  //函数  返回的是一个char *指针
char *(*pf)(char *p); // 函数指针pf
pf = fun;   //函数指针pf指向函数fun
```

### 🏷 面向对象三大特征

#### 封装

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或对象操作，对不可信的进行隐藏

#### 继承

派生类继承基类

#### **多态**

消息以多种形式展现的能力

多态是以封装和继承为基础的

C++多态分类以及实现：

> 1、重载多态（编译期，静态多态）：函数重载，运算符重载
>
> 2、子类型多态（运行期，动态多态）：虚函数
>
> 3、参数多态性（编译期，静态多态）：类模板，函数模板
>
> 4、强制多态（运行期，动态）：基本类型转换，自定义类型转换

### 🏷 不能被继承的类

一个类不能被继承，也就是说它的子类不能构造父类，这样的子类就不能实例化这个子类，从而实现子类无法继承父类

我们可以将一类的构造函数声明为私有，使得这个类的构造函数对子类不可见，那么这个类就不能被继承了。

但是这样也引出了一个问题。客户程序也无法实例化这个类的实例。

**参考单例模式，用一个static函数来帮助创建这个类的实例**

```c++
class Cparent
{
  private:
      Cparent(int v){m_v = v};
  		~Cparent(){};
      int m_v;
      static Cparent *m_instance;
  public:
      static Cparent* getInstance(int v)
      {
        m_instance = new Cparent(v);
        return m_instance;
      }
}
```

### 🏷 析构函数

析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。

析构函数名也对应与 `~类名` 。它不能带任何参数，没有返回值（包括void）。只能有一个析构函数，不能重载。

如果用户没有编写析构函数，编译系统会自动生成一个省缺的析构函数（即使自定义了析构函数，编译器也总会为我们合成一个析构函数，编译器在执行的时候会先调用自定义的析构函数，再调用合成的析构函数），它也不进行任何的操作。许多简单的类中没有用显式的析构函数。

类析构顺序：1）派生类本身的析构函数，2）对象成员的析构函数，3）基类的析构函数。

### 🏷 虚函数virtual、纯虚函数

* 类如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作业就是为了能让这个函数在它的子类可以被覆盖，这样的话，编译器就可以使用后期绑定来达到多态。纯虚函数只是一个接口，是个函数声明而已，它要留到子类去实现。
* 虚函数在子类里可以不重写，但是纯虚函数必须在子类中实现才可以实例化子类
* 虚函数的类用作与”实作继承“，继承接口同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成
* 带有纯虚函数的类叫做抽象类，这种类不能直接生成对象，而且只能被继承，并且需重写其虚函数后，才能使用。
* 虚基类是虚继承中的记录

虚函数使用场景**：

使用一个基类指针指向一个派生类，基类指针只能用基类方法

换句话说，通过基类指针只能访问派生类的成员变量，不能访问派生类的方法

为了消除这种尴尬，让基类指针能够访问派生类的成员数据，C++增加了虚函数

**注意**：

* 带纯虚函数的类不能被实例化

* 构造函数不能是虚构函数，创建派生类的时候要调用派生类的构造函数，派生类的构造函数不能继承基类的构造函数
* 析构函数应该是虚函数，除非类不用做基类，默认的析构函数不能是虚函数
* 友元函数不能是虚函数，因为友元函数不是成员函数

#### 虚函数实现原理

[虚函数实现原理-原文](https://www.cnblogs.com/malecrab/p/5572730.html)                   图片来自原文

每一个含有虚函数（无论是其本身，还是继承而来的）的类都至少有一个与之对应的虚函数表，其存放着该类所有虚函数对应的函数指针。

![pic](https://images2015.cnblogs.com/blog/898333/201606/898333-20160609210402699-1501495771.png)

其中：

* B的虚函数表中存放着B::foo和B::bar两个函数指针。
* D的虚函数表中存放中继承自B的虚函数，还有自己的虚函数

**虚函数的构造过程**

![img](https://images2015.cnblogs.com/blog/898333/201606/898333-20160609210418246-1188626035.png)

**虚函数的调用过程**

![img](https://images2015.cnblogs.com/blog/898333/201606/898333-20160609210434386-1391536209.png)

编译器只知道`pb`是`B*`类型的指针，并不知道它指向的具体对象类型：`pb`可能指向的是`B`的对象，也可能指向的是`D`的对象

但是对于 `pb->bar()` ，编译器能够确定的是：此处 `operator->` 的另外一个参数就是 `B::bar` （因为 `pb`是 `B*` 类型的，编译器认为 `bar` 是 `B::bar`），而`B::bar`和`D::bar`在各自的虚函数表中偏移位置是相等的。

无论`pb`指向哪种类型的对象，只要能够确定被调函数在虚函数中的偏移量，待运行时，就能确定具体类型，并找到相应的`vprt`了，就能调用具体类型，并能找到真正应该调用的函数。

**多重继承**

![img](https://images2015.cnblogs.com/blog/898333/201606/898333-20160609210449511-346261020.png)

其中：D自身的虚函数与B基类共用了一个虚函数表，因此称B为D的主基类。

虚函数替换过程和前面描述的类似，只是多个一个虚函数表，多了一次拷贝和替换的过程

### 🏷 虚继承

虚继承用于解决多继承条件下的菱形继承问题

### 🏷 重载和覆盖

**重载**：两个函数同名，但是参数列表**（参数个数，类型，顺序）**不同，返回值类型没有要求，在同一个作用域中，const修饰的同名函数也算。

> **用处**：用于处理实现功能相似而数据类型不同的问题，减少函数名的数量，避免名字空间的污染，提升可读性

**重写** ：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写

C++中不仅函数可以重载，运算符也可以重载

**❓c语言为什么不能支持函数重载？**

编译器只会对函数进行简单的重命名，不能区分

**❓C++函数重载底层是如何处理的？**

编译器将同名不同参的函数在符号表中生成不同的名字，编译器根据调用者传入的参数类型和个数可以唯一确定调用哪一个函数。

### 🏷 静态函数与虚函数

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次开销内存。

### 🏷 析构函数与虚函数

**❓为什么析构函数必须是虚函数？为什么默认的析构函数不是虚函数？**

1、将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类时，然后使用基类 指针指向该子类对象，释放基类指针可以释放掉子类的空间，防止内存泄漏

2、C++默认的析构函数不是虚函数，是因为虚函数需要额外的虚函数表和虚函数指针，占用额外的内存。而对不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当做父类时，设置为虚函数。

### 🏷 函数

**❓C++如何进行函数调用？**

每个函数调用都会分配函数栈，在栈内进行函数执行过程，调用前，先把返回地址压栈，然后把当前函数的esp指针压栈

**❓C++如何处理返回值**

生成一个临时变量，把它的引用作为函数参数传入函数内。

**❓C++中拷贝赋值函数的形参能否进行值传递？**

不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。如此循环，无法完成拷贝，栈也会满。

### 🏷 ❓delete this合法吗？

合法，但

* 必须保证 `this` 对象是通过 `new` 分配的
* 必须保证调用 `delete this` 的成员函数是最后调用`this`的成员函
* 必须保证成员函数的`delete this` 后面没有调用 `this` 了
* 必须保证 `delete this`后面没人使用了

### 🏷 ❓如何定义一个只能在堆上（栈上）生成的对象？

**只能在堆上**

方法：将析构函数设置为私有

原因：C++是静态绑定语言，编译器管理栈上的对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

**只能在栈上**

方法：将new和delete重载为私有

原因：在堆上生成对象，使用new关键字操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将new操作设置为私有，那么第一阶段就无法完成，就不能在堆上生成对象

## 📚STL

《STL源码解析》-侯捷

### 🏷 概述

STL提供六大组件

1、**容器**：各种数据结构， 如vector，list， deque, set， map，用来存放数据；

2、**算法**：各种常见算法如sort，search，copy，erase

3、**迭代器**：扮演容器与算法之间的胶合剂，是所谓的“泛型指针”

4、**仿函数**：行为类似函数，可以作为算法的某种策略

5、**配接器**：一种用来修饰容器或仿函数或迭代器接口的东西

6、**空间配置器**：负责空间配置与管理

### 🏷 空间配置器

[参考](https://blog.csdn.net/md521/article/details/42046043)

STL采用二级配置器结构

讨论的是---SGI空间配置器

**1、第一级配置器**

以malloc(), free(), realloc()等C函数执行实际内存配置、释放、重新配置等操作，若调用malloc(),realloc()不成功，会去循环调用“内存空间不足处理例程”，期望某次调用后获得足够的内存空间而圆满的完成任务，若还是不成功，返回异常

一级空间配置器分配的是大于128字节的内存

如果分配不成功，调用句柄释放一部分内存，若还是分配不成功，抛出异常

**2、二级配置器**

当配置区块超过128B时调用一级配置器；否则采用内存池管理空间分配

工作流程：

当使用二级配置器时，从自由链表维护的内存块中申请内存，若没有对应申请大小的自由链表，则从内存池中申请内存构造自由链表，内存池内存不足时，从堆中申请内存填充内存池（

**自由链表**：复杂维护不同大小的内存块，由于二级配置器会将内存需求量上调为8的倍数，且能够分配的最大内存为128B，则自由链表的个数为16个；每个链表分别维护内存大小为8，16，24，32，48......128的内存空间大小

![img](http://www.xyongs.cn/image/stl_malloc.png)

**一级配置器 __malloc_alloc_template 剖析**

```c
template<int inst>
class __malloc_alloc_template
{
  private:
  	//以下都是函数指针，所代表的函数将用来处理内存不足的情况
  	// oom: out of memory
  	static void *oom_malloc(size_t);
  	static void *oom_realloc(void*, size_t);
  	static void (* __malloc_alloc_oom_handler)();
  public:
  	static void * allocate(size_t n)
    {
      void *result = malloc(m);  //一级配置器直接使用malloc();
      if (0 ==  result) result = oom_malloc(n); //无法满足时，使用oom_malloc
      return result;
    }
  	static void deallocate(void *p, size_t)
    {
      free(p);  //一级配置器直接使用free释放
    }
  	static void *reallocate(void *p, size_t, size_t new_sz)
    {
      void *result = realloc(p, new_sz);  //一级配置器直接使用
      if (0 == result) result = oom_realloc(p, new_sz);
      return result;
    }
};
tempate<int inst>
void (* __malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = 0;

tempate<int inst>
void * __malloc_alloc_tempate<inst>::oom_malloc(size_t n)
{
  void (* my_alloc_handler)();
  void *result;
  
  for (;;){  //不断尝试释放、配置、再释放、再配置
    my_malloc_hander = __malloc_alloc_oom_handler;
    if (0 == my_malloc_hander) {__THROW_BQD_ALLOC;}
    (*my_malloc_hander)();  // 调用处理例程，企图释放内存
    result = malloc(n);   //再次尝试配置内存
    if (result) return (result);
  }
}

tempate<int inst>
void *__malloc_alloc_tempate<inst>::oom_realloc(void *p, size_t n)
{
  void (* my_alloc_handler)();
  void *result;
  for (;;){  //不断尝试释放、配置、再释放、再配置
    my_malloc_hander = __malloc_alloc_oom_handler;
    if (0 == my_malloc_hander) {__THROW_BQD_ALLOC;}
    (*my_malloc_hander)();  // 调用处理例程，企图释放内存
    result = realloc(p, n);   //再次尝试配置内存
    if (result) return (result);
  }
}
```

SGI 第一级配置器的 `allocate()` 和 `realloc()` 都是在调用`malloc()` 和`realloc()`不成功后，调用`oom_malloc()` 和 `oom_realloc()`. 后两者都有内循环，不断调用 "内存不足处理例程".

**第二级配置器 __default_alloc_template 剖析**

二级配置器多了一些机制，避免太多小额区块造成内部碎片

```cpp
enum {__ALIGN = 8};
enum {_MAX_BYTES = 128};
enum {_NFREELISTS = __MAX_BYTES/__ALIGN}; //free-lists个数
template<bool threads, int inst>
class __default_alloc_template {
private:
  // 将bytes上调至8的倍数
  static size_t ROUND_UP(size_t bytes){
    return (((bytes) + __ALIGN-1) & ~(__ALIGN - 1))
  }
private:
  union obj {  // free-lists节点构造
    union obj * free_list_link;
    char client_data[1];  
  };
private:
  //16个free-lists
  static obj * volatile free_list[_NFREELISTS];
  //根据块大小，决定使用第n号free-list. n 从 1 开始
  static size_ FREELIST_INDEX(size_t bytes){
    return (((bytes) + __ALIGN-1) / __ALIGN - 1);
  }
  //返回一个大小为n的对象，并可能加入大小为n的其他区块到freelist
  static void *refill(size_t n);
  
  //配置一大块空间，可容纳nobjs个大小为 size 的区块
  // 如配置nobjs个区块有所不便，nobjs可能会降低
  static char *chunk_alloc(size_t size, int &nobjs);
  
  static char *start_free;  //内存池起始位置
  static char *end_free;
  static size_t heap_size;
public:
  static void *allocate(size_t n);
  static void deallocate(void *p, size_t n);
  static void *reallocate(void *p, size_t old_sz, size_t new_sz);
};

//初始化
template<bool threads, int inst>
char *__default_alloc_template<threads, inst>::start_free = 0;
template<bool threads, int inst>
char *__default_alloc_template<threads, inst>::end_free = 0;
template<bool threads, int inst>
char __default_alloc_template<threads, inst>::heap_size = 0;
template<bool threads, int inst>
char __default_alloc_template<threads, inst>::obj *volatile 
  __default_alloc_template<threads, inst>::free_list[__NFREELISTS] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
```

**空间配置器函数 allocate()**

```c
static void * allocate(size_t n)
{
  obj *volatile * my_free_list;
  obj *result;
  
  //大于128调用一级配置器
  if (n > (size_t) __MAX_BYTES){
    return (malloc_alloc::allocate(n));
  }
  //寻找16个free lists中合适的一个
  my_free_list = free_list + FREELIST_INDEX(n);
  result = *my_free_list;
  if (0 == result)
  {
    //没有找到，准备重新填充free_list
    void *r = refill(ROUND_UP(n));
    return r;
  }
  //调整free list
  *my_free_list = result->free_list_link;
  return (result);
}
```

**重新填充free lists**

当`free list`中没有可以的区块了时，就调用 `refill()` 新的空间取自内存池，省缺的取得20个新节点。

**内存池**

当内存足够时，直接调出20个区块返回给`free list`, 如果不足20个，但是足够供应一个以上，就拨出这不足20个区块空间出去。

若完全没有空间了，便需要利用`malloc`在`heap`上配置内存，请求的内存为需求量的两倍，再加上一个随着配置次数增大而愈来愈多的附加量

**例**

假设，程序一开始就调用`chunk__alloc(32,20)`,于是`malloc()`配置40个32bytes区块，其中第1个交出，另19个交给`free_list[3]`维护，余20个留个内存池。

接下来程序调用`chunk_alloc(64, 20)`，此时`free_list[7]`空空如也，必须向内存池要求支持。内存池也只有 (32*20)/64 = 10个64bytes区块，就把这10个区块返回，第1个交给客端，余9个有`free_list[7]`维护。此时内存池为空，在申请是要加上**附加量**

另：若system_heap空间不足，想法去其它内存中取，若最后还是失败返回bad_alloc异常。

注：`chunk_alloc(b, s)` 向内存池中取空间 s个大小为b bytes

### 🏷 迭代器

根据STL中的分类，`iterator`包括：

**输入迭代器**（`Input Iterator`）：通过对输入迭代器解除引用，它将引用对象，而对象可能位于集合中。最严格的输入迭代只能以只读方式访问对象。例如：`istream`。 

**输出迭代器**（`Output Iterator`）：该类迭代器和`Input Iterator`极其相似，也只能单步向前迭代元素，不同的是该类迭代器对元素只有写的权力。例如：`ostream, inserter`。 

以上两种基本迭代器可进一步分为三类：

**前向迭代器**（`Forward Iterator`）：该类迭代器可以在一个正确的区间中进行读写操作，它拥有`Input Iterator`的所有特性，和`Output Iterator`的部分特性，以及单步向前迭代元素的能力。

**双向迭代器**（`Bidirectional Iterator`）：该类迭代器是在`Forward Iterator`的基础上提供了单步向后迭代元素的能力。例如：`list, set, multiset, map, multimap`。

**随机迭代器**（`Random Access Iterator`）：该类迭代器能完成上面所有迭代器的工作，它自己独有的特性就是可以像指针那样进行算术计算，而不是仅仅只有单步向前或向后迭代。例如：`vector, deque, string, array`。 

**1 Input Iterators**

`Input Iterator`只能逐元素的向前遍历，而且对元素是只读的，只能读取元素一次。通常这种情况发生在从标准输入设备（通常是键盘）读取数据时。

下面是`Input Iterator`的可用操作列表：

`*iter`: 只读访问对应的元素 

`iter->member`: 只读访问对应元素的成员 

`++iter`: 向前遍历一步（返回最新的位置) 

`iter++`: 向前遍历一步（返回原先的位置） 

`iter1 == iter2`: 判断两个迭代器是否相等 

`iter1 != iter2`：判断两个迭代器是否不等 

`TYPE(iter)`: 复制迭代器 

**2 Output Iterators**

`Output iterator`跟`Input Iterator`相对应，只能逐元素向前遍历，而且对元素是只写的(`*iter`操作不能作为右值，只能作为左值)，只能写入元素一次。通常这种情况发生在向标准输出设备(屏幕或者打印机)写入数据时，或者利用`inserter`向容器中追加新元素时。

**3 Forward Iterators**

`Forward Iterator`是`Input Iterator`和`Output Iterator`的结合，虽然也只能逐元素向前遍历，但可以对元素进行读写操作。下面看`Forward Iterator`的可用操作列表

**4 Bidirectional Iterators**

双向迭代器行为特征类似于`Forward Iterator`，只是额外增加了一个逐元素向后遍历的能力。所以对于双向迭代器可用的操作，除了包含`Forward Iterator`的所有操作外，多了一组向后遍历的操作：

**5 Random Access Iterators**

随机访问迭代器除了有双向迭代器的能力特征外，还可以进行元素随机访问。所以对于随机访问迭代器，增加了关于“迭代器运算”的一些操作。下面是除了双向迭代器的所有操作外，额外的操作列表：

### 🏷 序列式容器

#### vector

存储连续的线性空间

**vector的数据结构**

```c++
template<class T, class Alloc = alloc>
{
  protected:
  	iterator start;  //表示目前使用空间的头
  	iterator finish;  //表示目前使用空间的尾
  	iterator end_of_storage;  //表示目前可以空间的尾
}
```

vector**调用构造函数的操作流程**

```c
//构造函数，指定大小n，初值 value
vector<size_type n, const T& value> {fill_initialize(n, value);}

//填充并予以初始化
fill_initialize(size_type n, const T& value)
{
  start = allocate_and_fill(n, value);
  finish = start + n;
  end_of_storage = finish;
}

//配置而后填充
iterator allocate_and_fill(size_type n, const T& x)
{
  iterator result = data_allocator::allocate(n);  // 配置n个元素的空间
  uninitialized_fill_n(result, n, x);
  return result;
}
```



1、**迭代器**：Random Access Iterators。

vector维护一个连续线性空间，支持随机存取。

2、**构造与内存管理**

![image](http://www.xyongs.cn/image/vector.png)

当我们以push_back()将新元素插入vector尾端时，该函数首先检查是否还有备用空间，若有直接在备用空间中构造元素，并调整迭代器，若没有就扩充空间（重新配置、移动元素、释放原空间）

<font color="red">vector是动态增加大小的，它以原来大小的两倍配置一个较大的空间，然后将原内容拷贝过来，然后在开始在原内容中构造新元素，并释放原空间。</font>

3、**操作**

| 方法                        | 含义                           |
| --------------------------- | ------------------------------ |
| pop_back()                  | 将尾端元素拿掉，并调整大小     |
| resize()                    | 调整容器大小                   |
| capacity                    | 返回当前为vector分配的容量大小 |
| reserve(i.begin(), i.end()) | 反转vector                     |
| erase(it)                   | 删除某个位置上的元素           |
| insert(pos, n,x)            | pos位置插入n个x元素            |

#### list

保存线性空间，每次插入或删除一个元素就配置或释放一个空间。

1、**迭代器**

Bidirectional Iterators

list是一个双向链表，迭代器必须具备前移、后移能力

2、**构成与内存管理**

每次插入或删除一个元素就配置或释放一个空间，对于任何位置的插入或删除操作都是常数时间。

3、**操作**

| 方法                | 含义                                                     |
| ------------------- | -------------------------------------------------------- |
| push_front(it)      | 头结点插入元素                                           |
| push_back(it)       | 尾结点插入                                               |
| erase(it)           | 删除                                                     |
| pop_front()         |                                                          |
| pop_back()          |                                                          |
| clear()             |                                                          |
| remove(val)         | 将数值为val所有元素移除                                  |
| unique()            | 移除数值相同的连续元素，只有连续而相同的元素才会移除一个 |
| transfer(pos, f, l) | 将[f,l) 内的元素移动到pos之前                            |
| splice(pos,x)       | 将x接合与pos所指位置之前                                 |
| merge(list &x)      | x 合并到*this上，前提：两者得有序                        |
| find(f, e, 99)      | [f,e)范围内查找99                                        |

#### deque

双端队列，一种双向开口的连续线性空间，在头尾两端可插入和删除元素。

deque是由一段一段的定量连续空间构成，一旦有必要在的确的前端或尾端增加新空间，便配置一段定量连续空间，串联在整个deque的头端或尾端。

**1、deque中控器**

deque采用一块所谓的map（不是STL的map容器）作为主控，其中的每一个节点存储的都是指针，指向另外一段连续线性空间，称为缓冲区，缓冲区才是deque的存储空间主体。

**2、迭代器**

deque的迭代器必须能够指出分段连续空间（缓冲区）在哪里，其次它能够判断自己是否已经处于所在缓冲区的边缘，如果是，一旦前进或后退时就必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，deque必须随时掌控map。

![img](http://www.xyongs.cn/image/deque_it.png)

**3、deque的结构**

deque除了维护一个map结构的指针外，还维护start，finish两个迭代器，分别指向第一个缓冲区的第一个元素，和最后一个缓冲区的最后一个元素

![img](http://www.xyongs.cn/image/deque.png)

**4、deque扩容操作**

程序一开始声明了一个deque:

`deque<int, alloc, 32> ideq(20, 9)`

其缓冲区大小为32bytes， 并令其保留20个元素空间，每个元素初值为9。

当添加元素的一端只有一个元素空间时，先配置一整块新的缓冲区，中控器将这段的的首尾地址加入到map中，再设置新的元素内容，然后更改迭代器finish的状态

#### stack

stack是一种先进后出的数据结构，它只有一个出口，它是一种容器的配接器，它的底层可以由deque或者stack实现。

![image](http://www.xyongs.cn/image/stack.png)

stack没有迭代器

#### queue

是一种先进先出的数据结构，它有两个出口，从队尾加入元素，对首取元素

![img](http://www.xyongs.cn/image/queue.png)

没有迭代器，是容器配接器，以deque或list为底层数据结构

#### heap与priority_queue

heap并不属于STL的容器组件，是priority_queue的助手

priority_queue允许用于任何次序将任何元素推入容器内，但是取出时一定从优先权最高的元素开始取出

binary max heap(二叉大根堆)就有这样的特性，很适合作为priority_queue的底层机制

![img](http://www.xyongs.cn/image/heap.png)

它是将大根堆存储在Array或vector中

**特性**

* 队列特性
* 无迭代器

![img](http://www.xyongs.cn/image/priority_queue.png)

### 🏷 关联式容器

观念上类似关联数据库，每个元素都有一个key和value，当元素被插入到关联式容器中，容器内部便依照其键值得大小，以某种特定的规则将这个元素放置于合适的位置

**set**

底层：红黑树，有序，不可重复

**map**

底层：红黑树，有序，不可重复

**multiset**

底层红黑树，有序，可重复

**multimap**

底层红黑树，有序，可重复

**unordered_set**

底层哈希表，无序，不可重复

**unirdereded_multiset**

底层哈希表，无序，可重复

**unordered_map**

底层哈希表，无序，不可重复

**unordered_multimap**

底层哈希表，无序，可重复

#### hashtable

hash函数（散列函数）：除留取余法

**碰撞问题**

线性探测法：直接寻找后一个空位置

二次探测法：采用二次hash，对计算出的值再hash一遍

开链法：

#### 关联式容器比较

* map：底层红黑树，key不重复
* multimap: 底层红黑树，key可以重复
* Hashmap: 底层hashtable
* unordered_map:底层hashtable，C++11添加，空间复杂度比hashmap高 是C++11用来代替hashmap。支持复杂的对象做kay，key不重复

## 📚 数据结构

**顺序结构：**

栈，队列（非循环队列、循环队列），数组，vector

```cpp
//栈
template <class T>
struct stackNode
{
  T data;
  stackNode *next;
}
```

**链式结构**：

单链表，双链表，循环列表

**哈希表**

**树**：二叉搜索树，平衡二叉树，红黑树，哈夫曼树，前缀树

**图**：遍历（dfs， bfds), 最小生成树，最短路径，拓扑排序，AOE，关键路径

### 🏷 广义表

是一种非线性的数据结构，是线性表的一种推广。即[广义表]([https://baike.baidu.com/item/%E5%B9%BF%E4%B9%89%E8%A1%A8](https://baike.baidu.com/item/广义表))中方式对表元素的原子限制，容许它们具有自身结构。

![img](https://raw.githubusercontent.com/huihut/interview/master/images/GeneralizedList2.png)

### 🏷 哈希表

哈希：散列值，把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。

问题：散列值的空间远远小于输入的空间，不同的输入可能造成相同的输出。

碰撞：两个不同的输入值，根据同一散列函数计算出来的散列值相同的现象

常见Hash函数：

* 直接地址法：直接以key或者key加上某个常数作为哈希地址
* 数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。
* **除留余数法**：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址
* 分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。
* 平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。
* 伪随机数法：采用一个伪随机数当作哈希函数。
* 链地址法

- 将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。

### 🏷 二叉树🌲

```cpp
struct TreeNode
{
  type value;
  TreeNode *left, *right;
}
```

**遍历方式**

* 前序遍历：中左右
* 中序遍历：左中右
* 后续遍历：左右中

[从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/submissions/)

### 🏷 平衡二叉树（AVL)🌲

左右子树高度差不超过1，左右子树也是平衡二叉树

**旋转**：如果在AVL树中进行插入或删除节点操作后，可能导致AVL树失去平衡。这种失去平衡可以概括为4种姿态：LL（左左），LR， RR，RL。

参考：https://www.pdai.tech/md/algorithm/alg-basic-tree-balance.html

### 🏷 二叉搜索树(BST)🌲

满足平衡树要求，且每个节点中其左子树的数据都要小于等于根节点，右子树的数据都大于根节点

### 🏷 红黑树🌲

[红黑树](https://blog.csdn.net/tanrui519521/article/details/80980135)

红黑树是一棵二叉搜索树，它的每一个节点增加了存储节点颜色，红或黑；

通过任意一条从根到叶子简单路径上的颜色束缚，保证最长路径不超过最短路径的两倍

**性质**：

* 每一个节点不是红就是黑
* 根节点是黑的
* 没有连续的红节点
* 每个节点到叶子节点的路径中，黑色节点数目相同

**调整**：

1、变色

2、左旋

3 、右旋

**❓红黑树、B+树、B树的区别？**

* 红黑树的深度比较大，而B树和B+树的深度则小一些
* B+树将数据存储在叶子节点，同时通过链表的形式将他们链接在一个

**红黑树、B树、B+树的区别？**

### 🏷 B+ 树与B树

B+树是一种数据结构，是个n叉树，每个节点通常有很多个孩子，一棵B+树包含根节点，内部节点和叶子节点。

![img](http://www.xyongs.cn/image/B_tree.png)

**应用**： B+树通常用于数据库和文件系统中

**B+树需满足的条件**：

1. 节点的子树树和关键字树相同（B树是关键字数比子树少一）
2. 节点的关键字表示的是子树中的最大数，在子树中含有这个数据（子树最少m/2个，去上届）
3. 叶子节点包含了全部数据，同时符合左小右大的顺序

**B+树的特点**

* 关键字数和子树相同
* 非叶子仅做为索引，它的关键字和叶子节点有重复元素
* 叶子节点用指针连接在一起

**B+树的优点**

* 非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一时可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。
* 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动（不停的中序遍历）。

**B树需满足的条件**

* 若根节点不是终端节点，则至少有2棵子树，至多有M阶，即M棵子树
* 除根节点以外的所有非节点至少有M/2棵子树，至多有M棵子树（关键字数为子树数减一）
* 所有的叶子节点都位于同一层，叶子节点为失败节点，不存储数据

**B树的优点**

对于在内部节点的数据，可以直接得到，不必根据叶子节点来定位

### 🏷 哈夫曼树

参考[数据结构——哈夫曼(Huffman)树+哈夫曼编码](https://www.cnblogs.com/wkfvawl/p/9783271.html)

定义：给定一个n个权值作为n个叶子节点，构造一棵二叉树，若树的带权路径长度最小，则这棵树被称为哈夫曼树。

**带权路径**：所有（叶子节点*该节点的高度）之和   （根节点的高度为0）

**哈夫曼编码**：是哈夫曼编码的一种应用，广泛的应用于数据文件的压缩，他用字符在文件中出现的频率来建立0，1表示的字符的最优表示方式；

它以字符频率数作为叶子节点的权，这样出现频率越高的字符它的表示格式越短，这样达到压缩的目的。

![img](https://raw.githubusercontent.com/wangkuiwu/datastructs_and_algorithm/master/pictures/tree/huffman/03.jpg)

### 🏷 图

**定义**：是有顶点和有穷非空集合和顶点之间边的集合组成，通常表示为：G(V, E)，G表示一个图，V表示顶点集合，E表示边集合

**顶点的度**：顶点Vi的度就是与Vi相连边的个数。对于有向图来说，有分入度和出度。

**邻接**：两顶点存在一条边<v1,v2>

**路径**：v1可以通过若干条边到达v2，的若干条边组成的集合

**连通**：v1可以通过若干条边到达v2

**权**：边上的权重

#### 种类：

无向图：

如果图中任意两个顶点之间的边都是无向边---无向图。(v1,v2)

有向图：

任意两个顶点之间的边都是有向边，<v1,v2>

完全图：

* 无向完全图： 在无向图中， 任意两个顶点存在边
* 有向完全图：在有向图中，任意两个顶点都有互为相反的两条边。

#### 存储结构

**邻接矩阵法**：

无向图：

![img](http://www.xyongs.cn/image/graph1.png)

无向图：

![img](http://www.xyongs.cn/image/graph2.png)

**邻接表法：**

无向图：

![img](http://www.xyongs.cn/image/graph3.png)

有向图：

![img](http://www.xyongs.cn/image/graph4.png)

带权图：

![img](http://www.xyongs.cn/image/graph5.png)

**操作**

遍历：

* [BFS广度优先搜索](https://zh.wikipedia.org/wiki/广度优先搜索)
* [DFS深度优先搜索](https://zh.wikipedia.org/wiki/深度优先搜索)
* 最小生成树
* 最短路径
* 拓扑排序 https://leetcode-cn.com/problems/course-schedule-ii/

## 📚 算法

### 🏷 排序

* [冒泡排序](https://goolory.github.io/2019/11/22/冒泡排序/)

> 算法描述
>
> - 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
> - 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
> - 针对所有的元素重复以上的步骤，除了最后一个；
> - 重复步骤1~3，直到排序完成。

* [选择排序](https://goolory.github.io/2019/11/22/SelectionSort/)

> 算法描述
>
> - n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：
> - 初始状态：无序区为R[1..n]，有序区为空；
>   第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
> - n-1趟结束，数组有序化了。

* [插入排序](https://goolory.github.io/2019/11/22/插入排序/)

> 具体算法描述如下：
>
> - 从第一个元素开始，该元素可以认为已经被排序；
> - 取出下一个元素，在已经排序的元素序列中从后向前扫描；
> - 如果该元素（已排序）大于新元素，将该元素移到下一位置；
> - 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
> - 将新元素插入到该位置后；
> - 重复步骤2~5。

* [快速排序](https://goolory.github.io/2019/11/22/quickSort/)

> 算法描述
>
> - 从数列中挑出一个元素，称为 “基准”（pivot）；
> - 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
> - 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

* 堆排序
* [归并排序](https://goolory.github.io/2019/11/22/mergeSort/)

> 算法描述
>
> - 把长度为n的输入序列分成两个长度为n/2的子序列；
> - 对这两个子序列分别采用归并排序；
> - 将两个排序好的子序列合并成一个最终的排序序列。

* [希尔排序](https://goolory.github.io/2019/11/22/shellSort/)

> 算法描述
> 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：
>
> - 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
> - 按增量序列个数k，对序列进行k 趟排序；
> - 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

* 计数排序
* 桶排序
* 基数排序

### 🏷 查找

* 顺序查找
* 二分查找

[在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array)

[寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number)

[山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array)

[数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof)

* 插值插值
* 哈希查找
* 红黑树

### 🏷 并查集

在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（Union-find Algorithm）定义了两个用于此数据结构的操作：

Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。
Union：将两个子集合并成同一个集合。
由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（Union-find Data Structure）或合并-查找集合（Merge-find Set）。
为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x)Find(x) 返回 xx 所属集合的代表，而 Union 使用两个集合的代表作为参数。

链接：https://leetcode-cn.com/tag/union-find/

### 🏷 动态规划

通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题

[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring)

[跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii)

[最大子序和](https://leetcode-cn.com/problems/maximum-subarray)

### 🏷 贪心法

一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法

[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

### 🏷 分治法

把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并

快速排序，归并排序

### 🏷 加密算法

#### 单向加密

单向加密又称不可逆加密算法，其密钥是由加密散列函数生成的。单向散列函数一般用于产生消息摘要，密钥加密等，常见的有：

* MD5:是RSA数据安全公司开发的一种单向散列算法，非可逆，相同明文产生相同密文
* SHA：可以对任意长度的数据运行生成一个160位的数值。其变种有SHA192，SHA256
* CRC-32：主要用于通过校验功能；

算法特征：

* 输入一样，输出必然相同；
* 雪崩效应，输入的微小改变，将会引起结果的巨大变化
* 定长输出，无论原始数据多大，结果大小是相同的；
* 不可逆，无法根据特征码还原出原来的数据；

#### 对称加密

采用单钥密码系统的加密方式，同一个密钥可以同时作用信息加密和解密，这种加密方式称为对称加密，也称为单密钥加密

特点：

* 加密方和解密方使用同一密钥；
* 加密解密的速度比较快，适合数据比较长时的使用
* 密钥传输不安全，且容易被破解，密钥管理也比较麻烦

优点：

对称加密算法的优点是公开，计算量小，加密速度快，加密效率高

缺点：

对称加密算法的缺点在于数据发送前，发送方和接受方必须都商定好密钥，然后使双方能保持好密钥。其次如果一方密钥被泄漏，那么加密信息就不安全了。另外，每对用户使用对称加密算法时，都需要使用其他人不知道的唯一密钥，这会使得收发双方都拥有的钥匙数量巨大，密钥管理称为双方的负担

#### 非对称加密

公钥加密，由一对公钥和私钥组成，公钥是从私钥中提取出来的。可以用公钥加密，在使用私钥解密，这种情形一般用于公钥加密，当然也可以使用私钥加密，公钥解密。常用于数字签名，因此非对称加密主要功能是加密和数字签名

特征：

* 密钥对
* 主要功能：加密和签名。发送方用对方公钥加密，可以保证数据的机密性（公钥加密）。发送方用自己的私钥加密，可实现身份验证（数字签名）
* 公钥加密算法很少用来加密数据，速度太慢，通常用来实现身份验证

常用算法：

RSA：RSA公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度是可变的；既可以实现加密，又可以实现签名

#### MD5

Message-Digest Algorithm 5（信息-摘要算法）。前有MD3、MD4

MD5是输入不定长度信息，输出固定长度128-bits的算法，经过程序流程，生成四个32位数据，最后联合起来成为一个128-bits散列。

基本方式为：求余，取余，调整长度，与链接变量进行循环运算。得出结果。

**不足：**

散列长度为128，随着计算机运算能力提高，找到“碰撞”是可能。

### 🏷 洗牌算法

从原始数组中随机取一个之前没有取到过的数字到新的数字中

算法步骤为：

1. 建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值；

2. 生成一个从 0 到 n - 1 的随机数 x；

3. 输出 arr 下标为 x 的数值，即为第一个随机数；

4. 将 arr 的尾元素和下标为 x 的元素互换；

5. 同2，生成一个从 0 到 n - 2 的随机数 x；

6. 输出 arr 下标为 x 的数值，为第二个随机数；

7. 将 arr 的倒数第二个元素和下标为 x 的元素互换；

……

如上，直到输出m 个数为止

时间复杂度为O(n)，空间复杂度为O(1)，缺点必须知道数组长度n。

## 📚 操作系统

### 🏷 地址空间

地址空间：物理地址空间，逻辑地址空间

 逻辑地址空间 -- 程序-汇编-链接--

物理地址空间的生成：内存的逻辑地址空间会有一个到物理地址的映射

连续内存的分配

**内存碎片问题：**

1）外部碎片，指的是还没有分配除去，但是由于太小无法分配

2）内部碎片，已经分配出去但是不能被利用

**内存分配算法：**（1）首次适配 （2）最优适配 （3）最差适配

（1）首次适配：按地址排序的空间列表，容易产生外部碎片

（2）最优适配算法：选择差值最小的空闲块，容易产生很多没使用的微小碎片。

（3） 最差分配算法，选择差值最大的空闲块，破碎了大块的空闲块以至于无法被分配

**进一步处理使得内存碎片消失的办法**

（1）压缩碎片整理：重置所有程序以合并空块，要求所有的程序是动态可以重置的，缺陷：重复拷贝，内存开销比较大

（2）交换式碎片整理：抢占等待的程序

**内存非连续分配管理方式：**https://www.cnblogs.com/felixfang/p/3420462.html

**1、分页**

*把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位*。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。

**分页存储管理的逻辑地址结构如图所示：**

![img](http://xyongs.cn/image/memory1.png)

地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W。地址长度为32 位，其中011位为页内地址，即每页大小为4KB；1231位为页号，地址空间最多允许有2^20(1M)页。

1.3 页表

为了便于在内存中找到进程的每个页面所对应的物理块，**系统为每个进程建立一张页表**，记录页面在内存中对应的物理块号，页表一般存放在内存中。

进程通过查表得到每页在内存中的物理块号。由页表实现了从页号到物理块号的地址映射。如下图所示：

![img](http://xyongs.cn/image/memory2.png)

4 两级和多级页表

现代大多数计算机系统都支持非常大的逻辑地址空间（232~264），在这样的环境下，页表就变得非常大，要占很大的内存空间。32 位逻辑地址空间、页面大小4KB、页表项大小4B为例，若要实现进程对全部逻辑地址空间的映射，则每个进程需要2^20个页表项。也就是说，每个进程仅页表这一项就需要4MB主存空间，这显然是不切实际的。

此问题解决分两方面：一方面，只将当前需要的部分表项调入内存，其余的页表仍然驻留在磁盘上，需要时再调入。另一方面，需要对页表映射的思想进一步延伸，就可以得到二级分页。

分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明；

而分段管理方式的提出则是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。

**1 分段**

段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0 开始编址，并分配一段连续的地址空间（**段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的**）。其逻辑地址由段号S与段内偏移量W两部分组成。

2 段表

*每个进程都有一张逻辑空间与内存空间映射的段表*，其中每一个段表项对应进程的一个段，段表项记录该段在内存中的起始地址和段的长度。

**段页式管理方式**

页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。

在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，对内存的分配以存储块为单位，

链接：https://www.jianshu.com/p/7bfe9bb44c07

## 📚 计算机网络

**参考**

《计算机自顶向下》

https://blog.csdn.net/ThinkWon/article/details/104903925

**❓网络协议是什么？**

在计算机网络中要做到有条不紊的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式，是否需要发送一个应答消息。这些规则被称为网络协议。

##### 四层网络结构和其上协议

| 层         | 协议                          | 设备                                             |
| ---------- | ----------------------------- | ------------------------------------------------ |
| 应用层     | 用户进程                      | 软件                                             |
| 传输层     | TCP    UDP                    | 网关                                             |
| 网络层     | ICMP    IP   IGMP             | 路由器，三层交换机，hub                          |
| 数据链路层 | ARP    以太网接口程序    RARP | 物理层：中继器、集线器；数据链路层：交换器、网桥 |

**ICMP(报文控制协议)：**

> 确认IP包是否成功到达目的地址，通知在发送过程中IP包被丢弃的原因
>
> **ping程序**：采用的就是该协议，测试一台主机是否可到达；该程序发送ICMP回显请求报文给主机等待主机回复ICMP回复报文

IGMP(互联网组管理协议)

> 是TCP/IP协议族中负责IP组播成员管理的协议，用来在IP主机和其直接相邻的组播路由器之间建立、维护组播成员关系。
>
> 目的：IP组播通信的特点是报文从一个源出发到一组特定的接受者。但在组播通信模型中，发送者不再关注接收者的位置信息，只是将数据发送到约定的目的组播地址。要使组播报文中最终能够到达接受者，需要某种机制使链接接受者网段的组播路由器能够了解到该网段存在哪些组播协议者，同时保证接受者可以加入相应的组播组中。IGMP协议就是用来在接受者主机与其所在网段直接相邻的组播路由器建立、维护组播成员关系的协议
>
> 工作机制：
>
> 1. 接受者主机向所在的共享网络报告组成员关系
> 2. 处于同一网段的所有使用了IGMP功能的组播路由器选举出一台作为查询器，查询器周期性向该共享网段发送组成员查询消息；
> 3. 接受者主机接收到该查询消息后进行应答以报告成员关系
> 4. 网段中的组播路由器依次根据接收的应答来刷新组成员的存在信息。如果超时无响应，组播路由器就认为网段中没有该组播的成员，从而取消相应的组播数据转发。
> 5. 所以参与组播传输的接受者主机必须应用IGMP协议，主机可以在任何时间、任何位置、成员数不受限制得加入或退出组播组
> 6. 支持组播的路由器不需要也不可能保存所有的主机成员关系，它只需通过IGMP协议了解每个接口连接的网段上是否存在某个组播接收者，即组成员。而各主机只需要保存自己加入了哪些组播组
>
> IGMPv1工作原理:
>
> 两种类型的报文：
>
> * 普通组查询报文：查询器向共享网络上所有主机和路由器发送的查询报文，用于了解哪些组播组存在成员。
>
> * 成员报告报文：主机向查询器发送的报告报文，用于申请加入某个组播或者应答查询报文。

**ARP（地址解析协议）：**

> 将32为的IP地址转为48位以太网地址
>
> 过程：
>
> 1、ARP请求，当主机需要找出网络中的另一个主机的物理地址时，他会发送一个ARP报文，这个报文包好了发送方的MAC地址和IP地址以及接收方的IP地址。因为发送方不知道接收方的物理地址，所以这个查询分组会在网络层中进行广播。
>
> 2、ARP响应
>
> 局域网中的每一台主机都会接受并处理这个ARP请求报文，然后进行验证，查看接收方的IP地址是不是自己的地址，只有验证成功的主机才会返回一个ARP响应报文，这个响应报文包含接收方的IP地址和物理地址。这个报文利用收到的ARP请求报文中的请求方物理地址以单播的方式直接发送给ARP请求报文的请求方。

**RARP（逆地址解析协议）**

> 如主机只知道自己的物理地址，而不知道IP地址，发送RARP协议包到--->RARP服务器---->返回响应包

### 🏷 网络协议分层

❓**为什么要对网络协议进行分层？**

* 简化问题难道和复杂度。由与各层之间独立，可以分割大问题为小问题
* 灵活性好。当其中一层的技术变化时，只需要层间接口关系保持不变，其他层不受影响
* 易于实现和维护
* 促进标准化工作。

网络协议分层的缺点：功能可能出现在多个层里，产生额外的开销

分层：

![img](http://xyongs.cn/image/network_pro_530.png)

**OSI七层模型及其包含的协议**

| 层         | 作用                               | 协议           |
| ---------- | ---------------------------------- | -------------- |
| 应用层     | 允许访问OSI环境的手段              | FTP，HTTP，DNS |
| 表示层     | 对数据进行翻译、加密、压缩         | JPEG，ASII     |
| 会话层     | 建立、管理和终止会话               | RPC，NFS       |
| 传输层     | 提供端到端的数据传输               | TCP，UDP       |
| 网络层     | 负责数据包从源到宿的传递和网际交互 | IP，ICMP，IGMP |
| 数据链路层 | 将比特组装成帧和点到点传输         | MAC，VLAN，PPP |
| 物理层     | 通过媒介传输比特                   | IEEE802.3      |

### 🏷 应用层

应用层的任务时通过应用进程间的交互来完成特点的网络应用。应用层协议定义的是应用进程间的通信和交互的规则。

对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，HTTP，SMTP

#### DNS解析

DNS基于UDP服务，端口53。HTTP，SMTP等在其中需要完成主机名到IP地址的转换

**递归查询与迭代查询**

**递归查询：**是DNS服务器的查询模式，该模式下DNS服务器接收到客户机请求，必须使用一个准确地查询结果回复客户机。如果DNS服务器没有存储DNS信息，那么该服务器会询问其他的服务器，并将返回的查询结果提交给客户机。

![img](http://xyongs.cn/image/network_DNS_1_530.png)

**迭代查询**

DNS服务器会向客户机提供其他能够解析查询请求的DNS服务器地址。当客户机发送查询请求时，DNS服务器不直接回复查询结果，而是告诉客户机另一台DNS的服务器地址，客服机在向这台DNS服务器提交请求，循环此操作。

![img](http://xyongs.cn/image/network_DNS_2_530.png)

**DNS劫持**

DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。

**DNS污染**

DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。

其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改，通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。

DNS污染发生在用户请求的第一步上，直接从协议上对用户的DNS请求进行干扰。

DNS污染症状：目前一些被禁止访问的网站很多就是通过DNS污染来实现的，例如YouTube、Facebook等网站。

**解决办法**：

对于DNS污染，可以说，个人用户很难单单靠设置解决，通常可以使用VPN或者域名远程解析的方法解决，但这大多需要购买付费的VPN或SSH等，也可以通过修改Hosts的方法，手动设置域名正确的IP地址。

#### HTTP

参考：https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md

##### HTTP工作流程

![img](http://xyongs.cn/image/HTTP-work-6-4.png)

##### 基本概念：

URI（uniform Resource Indentifier): 统一资源标识符

> 其中包含：
>
> URL统一资源定位符：https://www.google.com
>
> URN 统一资源名称

请求报文和响应报文：

都是有报头和报文体组成，中间以空行隔开

1. 请求报文

![img](http://xyongs.cn/image/HTTP-req-6-4.png)

2. 响应报文

![img](http://xyongs.cn/image/HTTP-res-6-4.png)

##### HTTP 常用方法

| 方法    | 作用                       | 备注                                                         |
| ------- | -------------------------- | ------------------------------------------------------------ |
| GET     | 获取资源                   | 当前网络请求中，大多使用GET方法                              |
| HEAD    | 获取报文首部               | 和GET方法类似，但不返回报文实体主体部分<br />主要用于确认URL的有效性及资源更新时间 |
| POST    | 传输实体主体               | 传输数据                                                     |
| PUT     | 上传文件                   | 由于不带验证机制，任何人都可上传文件，一般不使用             |
| DELETE  | 删除                       | 与PUT功能相反，不带验证机制                                  |
| OPTIONS | 查询支持的方法             | 查询指定URL能够支持的方法<br />返回：`Allow: GET, POST, HEAD`等内容 |
| CONNECT | 与代理服务器通信时建立隧道 |                                                              |

##### HTTP返回码

| 状态码 | 类别         | 含义                       | 实例                                                         |
| ------ | ------------ | -------------------------- | ------------------------------------------------------------ |
| 1XX    | 信息性状态码 | 接收的请求正在处理         |                                                              |
| 2XX    | 成功状态码   | 请求正常处理完毕           | 200 OK：客户端请求成功<br />201：服务器接收到请求，稍后会处理<br />206 partial content：服务器正确处理部分GET请求 |
| 3XX    | 重定向状态码 | 需要进行附加操作以完成请求 | 301（永久重定向）<br />302（临时重定向）                     |
| 4XX    | 客户端错误   | 客户端错误                 | 401：客户端试图访问一个受保护的资源<br />403：禁止访问<br />404：访问资源不存在 |
| 5XX    | 服务器端错误 | 服务器错误                 | 500：服务器响应错误<br />502：网关错误                       |

##### 长连接与短连接

当浏览器访问一个包含多张图片的HTML页面时，除了请求访问的HTML资源，还会请求图片资源。如果每次进行一次TCP通信就要新建一个TCP连接，那么开销会很大。

长连接只需建立一次TCP连接就可以进行多次HTTP通信。

* 从HTTP/1.1开始默认是长连接的，如果要断开连接，需要由客户端或服务器端提出断开，使用`connection:close`
* 在HTTP/1.1之后默认使用的是短连接，如果需要使用长连接，则使用`Connection:Keep-Alive`。

##### 流水线

默认情况下，HTTP请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间

流水线就是在同一条长连接上连续发送请求，而不用等待响应返回，这样就可以减少延迟

##### cookie与session

###### cookie

HTTP协议是无状态的，主要是为了让HTTP协议尽可能简单，使得它能够处理大量事务。HTTP/1.1引入Cookie来保存状态信息。

cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发送请求时被携带上，用户告知服务器两个请求时来自同一浏览器。

随着现代浏览器发展，其开始支持各种各样的存储方式，cookie渐渐被淘汰。新的浏览器API已经允许开发者直接将数据存储在本地，如使用web storage API 

**用途**

* 会话状态管理（如用户登录状态、购物车等需要记录的信息）
* 个性化设置（如用户自定义设置、主题）
* 浏览器行为跟踪（如跟踪分析用户行为）

**创建过程**

服务器发送的响应报文包含set-cookie首部字段，客户端得到响应报文后把cookie中内存保存到浏览器中

```
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
```

客户端之后对同一服务器发送请求时，会从浏览器中取出cookie信息通过cookie请求首部字段发给服务器

```
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

###### session

由于HTTP的无状态导致，服务器不知道请求方是谁，session可以用于维护用户登录状态

除了可以将用户信息通过cookie存储在用户浏览器中，也可以使用session存储在服务器，存储在服务器更安全

session可以存储在服务器的文件、数据库或者内存中。

**过程**

1. 浏览器第一次请求网站资源，服务器生成session ID
2. 把生成的session ID保存在服务器端存储
3. 把生成的session ID通过set-cookie返回给浏览器
4. 浏览器接收到session ID，在下一次发送请求时会带上这个session ID
5. 此后的请求都会交换这个session ID，进行有状态的会话

**session ID劫持**

假如session ID是基于HTTP传输的，因为是明文传输，可能被中间的路由器劫持，攻击者得到session ID后，把它带到自己的请求中，就能够进入你的账户

处理方法：动态时间间隔内刷新session ID，加上Token

###### cookie和session应用

* cookie只能存储ASCII码字符串，而session则可以存储任何类型的数据
* cookie只能存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存放在cookie中，可以将值进行加密，在服务器端解密
* 对于大型网站，如果用户所有信息都存储在session中，那么开销非常大，因此不建议将所有的信息都存储到session中

#### HTTPS

HTTP有一下安全问题

* 使用明文传输，内容可能被窃听
* 不验证对方身份，通信方的身份可能遭遇伪装
* 无法证明报文的完整性，报文有可能遭到篡改

HTTPS不是新的协议，而是让HTTP先和SSL（secure sockets Layer）通信，再由SSL和TCP通信，也就是说HTTPS使用了隧道进行通信

**优点**：

* 传输数据过程使用秘钥进行加密，安全性高
* 可以认证用户和服务器，确保数据发送到正确的用户和服务器

**缺点：**

* 时延高
* 部署成本高
* 需要加密解密计算，占用资源多

##### HTTPS工作流程

https://github.com/ljianshu/Blog/issues/50

准备工作：首先客户端浏览器安装一些权威第三方机构的公钥 ，服务器端向三方机构申请自己的数字证书

![img](http://xyongs.cn/image/HTTPS-work-6-5.png)

1. Client发起一个HTTPS请求，根据RFC2818的规定，Client需要连接到Server的443（默认）端口
2. Server把事先配置好的公钥证书返回给客户端
3. Client验证公钥证书：比如是否在有效期内
4. Client使用伪随机数生成器加密所使用的对称秘钥（会话秘钥），然后用证书的公钥加密这个对称秘钥，发给server
5. server使用自己的私钥解密这个消息，得到对称秘钥。至此，Client和server都持有了对方的秘钥
6. Server使用对称秘钥加密“A”，发送给Client
7. Client使用对称秘钥解密，得到A
8. Client再次发起HTTP请求，使用对称秘钥加密信息B，Server解密

client使用的是对称加密（加密解密使同一秘钥），server使用的是非对称加密（接收Client的会话秘钥）

##### 第三方认证

https://juejin.im/post/5b0274ac6fb9a07aaa118f49

![img](http://xyongs.cn/image/HTTPS-1-6-5.png)

**数字证书 = 网站信息 + 数字签名**

> 客户端使用该三方机构的公钥对证书中的数字签名进行解密，然后依据证书中的 网站信息进行签名生成，如果对比发现不匹配，请求失败

##### HTTP与HTTPS区别

1. HTTP是明文传输，HTTPS传输的数据经过TLS加密后的
2. HTTPS在TCP三次握手后，还需要进行SSL的handshake，协商加密使用的是对称加密秘钥
3. HTTPS协议需要服务器端申请证书，浏览器端安装对应的根证书
4. HTTP协议端口是80,HTTPS是443

![img](http://xyongs.cn/image/HTTPS-SSL-6-5.png)

#### 常见问题

**GET和POST区别**
说道GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的两种方法。

HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。

HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4种，分别是GET，POST，PUT，DELETE。这四种方法可以理解为，对服务器资源的查，改，增，删。

1. GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。
2. POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。
3. PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。
4. DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。

**区别：**

* Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。

* Get请求提交的url中的数据最多只能是2048字节，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。Post请求则没有大小限制。

* Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。

* Get执行效率却比Post方法好。Get是form提交的默认方法。

* GET产生一个TCP数据包；POST产生两个TCP数据包。

* 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

* 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

### 🏷 运输层

运输层的主要任务就是向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。

运输层主要使用TCP，UDP协议

|              | UDP                                  | TCP                              |
| ------------ | ------------------------------------ | -------------------------------- |
| 是否连接     | 无连接                               | 面向连接                         |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制 | 可靠传输，使用流量控制和拥塞控制 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多   | 一对一                           |
| 传输方式     | 面向报文                             | 面向字节流                       |
| 首部开销     | 小，仅8字节                          | 最小20字节，最大60字节           |
| 场景         | 实时应用（IP电话，视频会议，直播）   | 用于可靠传输，如文件传输         |

**运行在TCP协议上的协议：**

HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。
HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。
FTP（File Transfer Protocol，文件传输协议），用于文件传输。
POP3（Post Office Protocol, version 3，邮局协议），收邮件用。
SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。
TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。
SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。
**运行在UDP协议上的协议：**

**BOOTP（Boot Protocol，启动协议），应用于无盘设备。
NTP（Network Time Protocol，网络时间协议），用于网络同步。
DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。
**运行在TCP和UDP协议上：**

DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。

#### TCP协议

**TCP提供一种面向连接的、可靠的字节流服务**

![img](http://xyongs.cn/image/TCP-6-4.png)

源端口和目的端口分别包含了16bit，此处限定了计算机的端口数量2^16

##### TCP 建立连接----三次握手

1、客户端发送一个SYN段指明打算连接的服务器端口，以及初始序号（ISN）

2、服务器发回包含服务器的初始序号的SYN报文段作为应答，同时将确认序号设置为客户的ISN加一以对客户的SYN报文进行确认；

3、客户确认序号设置为服务器的ISN加一，对服务器的SYN报文确认

![img](http://xyongs.cn/image/TCP.png)

##### 为什么TCP客户端最后还要发送一次确认呢

一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

##### TCP断开连接--四次挥手

客户端发送一个FIN报文（报文4）给服务器，表示我将关闭客户端到服务器端这个方向的连接。

服务器收到报文4后，发送一个ACK报文（报文5）给客户端，序号为报文4的序号加1。

服务器发送一个FIN报文（报文6）给客户端，表示自己也将关闭服务器端到客户端这个方向的连接。

客户端收到报文6后，发回一个ACK报文（报文7）给服务器，序号为报文6的序号加1。

**理由**

**这是由于TCP的半关闭造成的。既然一个TCP连接是双全工的，因此每个方向必须单独地进行关闭。**

![img](http://xyongs.cn/image/image1.png)

##### 为什么客户端最后还要等待2MSL？

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

##### 为什么建立连接是三次握手，关闭连接确是四次挥手呢

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 

而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

**TCP状态转移图**

![img](http://xyongs.cn/image/TCP-6-3.png)

**如果已经建立了连接，但是客户端突然出现故障了怎么办？**

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

##### TCP 可靠性保证

1. 序列号、确认应答、超时重传
2. 窗口控制与快重传
3. 拥塞控制
4. 差错控制

##### 数据分片

数据从主机传送到另一个主机往往要经过路由器，网关等设备。这些设备都要对经过的数据进行处理。由于这些设备处理数据的能力有有一定限制，不能处理超出额定字节的数据，所以发送的时候需要确定发送数据包的最大字节数。

##### 滑动窗口机制

在进行数据传输时，如果传输的数据比较大，需要拆分为多个数据包进行发送。TCP协议需要对数据包进行确认才能发送下一个数据包。

这样一来会在等待确认应答包环节浪费时间。为了避免这种情况，引入窗口概念。

窗口大小：指不需要等待确认应答包而可以继续发送数据包的最大值

![img](http://xyongs.cn/image/image2.png)



当发送端接收到确认应答包后向后滑动

![img](http://xyongs.cn/image/image3.png)



**发送数据包丢失**

![img](http://xyongs.cn/image/image4.png)

下面分为 7 部分对上图进行讲解。

1) 发送端发送数据包：这里窗口大小为 4，发送端发送 4 个数据包，分别为 1-1000、1001-2000、2001-3000 和 3001-4000。

2) 接收端返回确认应答包：接收端接收到这些数据，并给出确认应答包。接收端收到了数据包 1-1000，返回了确认应答包；收到了数据包 1001-2000，返回了确认应答包；但是数据包 2001-3000，在发送过程中丢失了，没有成功到达接收端。数据包 3001-4000 没有丢失，成功到达了接收端，但是该数据包不是接收端应该接收的数据包，数据包 2001-3000 才是真正应该接收的数据包。因此收到数据包 3001-4000 以后，接收端第一次返回下一个应该发送 2001 的数据包的确认应答包。

3) 发送端发送数据包：发送端仍然继续向接收端发送 4 个数据包，分别为 4001-5000、5001-6000、6001-7000 和 7001-8000。

4) 接收端返回确认应答包：接收端接收到这些数据，并给出确认应答包。当接收端收到数据包 4001-5000 时，发现不是自己应该接收的数据包 2001-3000，第二次返回下一个应该发送 2001 的数据包的确认应答包。当接收端收到数据包 5001-6000 时，仍然发现不是自己应该接收的数据包 2001-3000，第三次返回下一个应该发送 2001 的数据包的确认应答包。以此类推直到接收完所有数据包，接收端都返回下一个应该发送 2001 的数据包的确认应答包。

5) 发送端重发数据包：发送端连续 3 次收到接收端发来的下一个应该发送 2001 的数据包的确认应答包，认为数据包 2001-3000 丢失了，就进行重发该数据包。

6) 接收端收到重发数据包：接收端收到重发数据包以后，查看这次是自己应该接收的数据包 2001-3000，并返回确认应答包，告诉发送端，下一个该接收 8001 的数据包了。

7) 发送端发送数据包：发送端收到确认应答包后，继续发送窗口大小为 4 的数据包，分别为 8001-9000、9001-10000、10001-11000 和 11001-12000。

##### TCP 流量控制

在使用滑动窗口机制进行数据传输时，发送方根据实际情况发送数据包，接收端接收数据包。但是，接收端处理数据包的能力是不同的。

1) 如果窗口过小，发送端发送少量的数据包，接收端很快就处理了，并且还能处理更多的数据包。这样，当传输比较大的数据时需要不停地等待发送方，造成很大的延迟。

2) 如果窗口过大，发送端发送大量的数据包，而接收端处理不了这么多的数据包，这样，就会堵塞链路。如果丢弃这些本应该接收的数据包，又会触发重发机制。

3) 为了避免这种现象的发生，TCP 提供了流控制。所谓的流控制就是使用不同的窗口大小发送数据包。发送端第一次以窗口大小（该窗口大小是根据链路带宽的大小来决定的）发送数据包，接收端接收这些数据包，并返回确认应答包，告诉发送端自己下次希望收到的数据包是多少（新的窗口大小），发送端收到确认应答包以后，将以该窗口大小进行发送数据包。

TCP 流控制过程如图所示。

![img](http://xyongs.cn/image/image5.png)

##### 拥塞控制

流量控制是由于接收方不能及时处理数据而引发的控制机制，拥塞是由于网络中的路由器超载而引起的严重延迟现象。拥塞的发生会造成数据的丢失，数据的丢失会引起超时重传，而超时重传会进一步加剧拥塞。

（大家都在用网，你在这里狂发，吞吐量就这么大，当然会堵）

在TCP的拥塞控制中，任然是利用**发送方的窗口**来控制注入网络中的数据流的速度。减缓注入网络的数据流

> 发送窗口大小 = min（接收方通告窗口大小，拥塞窗口大小）

<font color="red">**控制拥塞窗口且保持连接的可靠性，TCP采取的措施：**</font>

1. 慢启动：定义拥塞窗口，一开始将该窗口大小设置为1，之后每一次接收到确认应答，将拥塞窗口*2
2. 拥塞避免：设置慢启动阈值，一般一开始设置为2^16,。拥塞避免是指当拥塞窗口大小达到这个阈值时，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞

>  将报文段超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设置为当前窗口大小的一般，并且将窗口大小设置为初始值1，然后进入慢启动过程；

3. 快重传：在遇到3次重复确认应答是，代表收到了三个报文段，但是之前的一个段丢失了，便是对他立即进行重传；
4. 快恢复：收到3个重复确认应答后，先将阈值设置为当前窗口大小的一半，将拥塞窗口大小设置为慢启动阈值+3的大小。

这样可以达到：在TCP通信时，网络吞吐量呈逐渐上升，并且随着拥堵来降低吞吐量，在进入慢慢上升过程，网络不会轻易发送瘫痪。

#### 网络编程

Socket

![img](http://xyongs.cn/image/socket-6-5.jpg)

### 🏷 网络层

网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。

互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。

### 🏷 数据链路层

数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。

在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。

### 🏷 提问

##### 搜索百度，会用到计算机网络中的什么层，什么协议？每次做些什么？

在浏览器中输入URL

浏览器将URL解析为IP地址 （**应用层的DNS协议**），首先主机会查询DNS缓存，如果没有就发送查询请求

> DNS两种查询方式：1. 递归查询； 2. 迭代查询

得到IP地址后，浏览器就要与服务器建立一个HTTP连接。因此要用到**HTTP协议**，HTTP生成一个get请求报文，

将该报文传递给**传输层处理，会用到TCP协议**。如果采用了HTTPS还需对数据进行加密。TCP层如果有需要先将HTTP数据包分片

TCP数据之后会发生给**网络层（IP协议）**。IP层通过路由选路，一跳一跳的发送到目的地址。期间可能需要使用**数据链路层的ARP、RARP协议**

## 📚 MYSQL数据库

### 🏷 索引

数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用的是B树或B+树。

在数据库之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构之上实现高级查找算法。这些数据结构就是索引。

**作用**：协助快速查询、更新数据库中数据

**缺点**：

1. 增加了数据的存储空间；
2. 在插入和修改数据时要花费较多的时间（因为索引也要随之改变）

**适合建立索引的字段：（唯一，不为空，经常被查询的字段）**

1、在经常需要搜索的列上，可以加快搜索的速度

2、在主键的列上，强制该列的唯一性和组织表中数据的排列结构；

3、在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；

4、需要经常根据范围进行搜索的列上，因为索引已经排序，其指定范围是连续的

5、在经常需要排序的列上创建索引

6、经常使用where子句中

**不适合建立索引：**

1、查询中使用很少的

2、数据少的

3、text，image和bit要么数据大要么数据量小的

4、当修改性能远远大于检索性能，不应该创建索引。

------------------------------------

**❓MySQL B+ 树索引和Hash索引的区别？**

hash索引和B+树索引的特点：

1. Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位
2. B+树索引需要从根节点到枝叶节点，最后才能访问到叶节点，这样多次IO访问

区别：

1. Hash索引只能满足 "=" , "in" 查询，不能使用范围查询，因为经过相同的Hash算法处理后的Hash值的大小关系，并不能和hash算法运算前完全一致；
2. Hash索引无法被用来避免数据的排序操作，因为Hash值得大小关系并不一定和Hash运算前键值关系完成一样
3. Hash索引不能被利用部分索引间查询，
4. hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同的Hash值，所以即使取某个Hash键值得数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据

-----------------------

**❓B+树比B树更适合操作系统的文件索引和数据库索引？**

1、B+树的磁盘读写代价更低

2、B+树的查询效率更加稳定

聚集索引和非聚集索引的区别？

聚合索引：聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。

非聚合索引：

非聚合索引指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。

两者都是采用B+树结构

**根本区别：**

聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。

1、聚簇索引表记录的排列顺序和索引的排列顺序是一致的

2、聚簇索引一个表中只有一个，非聚簇可以有多个（200多个）

3、聚簇索引存储记录是物理上连续的存储，非聚集索引在逻辑上是连续的存在

**优点：**

聚簇：

1、以最快速度缩小查询范围

2、以最快的速度进行字段排序

使用场合：

1、此列包含的有限数目的不同值

2、查询的结果返回一个区间的值

3、查询的结果返回某值相同的大量结果集

非聚簇：

1、非聚簇索引比聚集索引层次多。

2、添加记录不会引起数据顺序的重组。

场合：

1、此列包含了大量数目不同的值

https://www.cnblogs.com/aspwebchh/p/6652855.html 参考

----------------------------------

聚集索引：通过主键将表的存储结构变成了树状机构，（整个表变成了一个索引）

一个表只能有一个主键，一个表只能有一个聚集索引

非聚集索引：（也就是我们平时经常提起和使用的常规索引）

每个（非聚类索引）之间不存在关联，索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直维护索引结构的正确性。

每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。

-------------

InNoDB（聚簇分布），利用主键将表存储为一个B+树的形式。二级索引存储的是关键字和主键

InNoDB按主键顺序插入行

若数据表中没有什么数据需要聚集，那么可以定义一个代理键作为主键，这种主键的数据和应用无关，最简单的方法就是自增列，这样可以保证数据行是按顺序输入

最好避免随机的聚簇索引，特别是对I/O密集型的应用，如使用UUID来作为聚簇索引：它使得索引的插入变得完全随机

UUID主键不仅插入行花费的时间更长，而且索引占用的空间更大。

----------------------------

**覆盖索引：**

**如果索引的叶子节点中已经包含了要查询的数据，那么还有什么必要在回表查询呢？**

**如果一个索引包含所有需要查询的字段的值，我们就称之为---覆盖索引**

**----查询只需要扫描索引而无需回表：**

**优点**：

1、减少数据访问量

2、减少IO

3、避免对主键的二次查询

### 🏷 数据库范式

**1NF**

​    **每个关系r的属性值为不可分的原子值**

**2NF**

 **满足1NF，非主属性完全函数依赖于候选键(左部不可约)**

**3NF**

 **满足2NF，消除非主属性对候选键的传递依赖**

**BCNF**

  **满足3NF，消除每一属性对候选键的传递依赖**

### 🏷 数据库事务

事务具有 4 个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持续性（Durability）。这 4 个特性简称为 ACID 特性。

**1) 原子性**

事务必须是原子工作单元，事务中的操作要么全部执行，要么全都不执行，不能只完成部分操作。原子性在数据库系统中，由恢复机制来实现。

**2) 一致性**

事务开始之前，数据库处于一致性的状态；事务结束后，数据库必须仍处于一致性状态。数据库一致性的定义是由用户负责的。例如，在银行转账中，用户可以定义转账前后两个账户金额之和保持不变。

**3) 隔离性**

系统必须保证事务不受其他并发执行事务的影响，即当多个事务同时运行时，各事务之间相互隔离，不可互相干扰。事务查看数据时所处的状态，要么是另一个并发事务修改它之前的状态，要么是另一个并发事务修改它之后的状态，事务不会查看中间状态的数据。隔离性通过系统的并发控制机制实现。

**4) 持久性**

一个已完成的事务对数据所做的任何变动在系统中是永久有效的，即使该事务产生的修改不正确，错误也将一直保持。持久性通过恢复机制实现，发生故障时，可以通过日志等手段恢复数据库信息。

------------------

#### 事务并发问题

1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读到的数据是脏数据

2、不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据进行了提交，导致数据A多次读取数据时前后数据结果不相同

3、幻读：幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）

**小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。**

#### 事务隔离级别

1. 读未提交（read-uncommitted)：可以读到未提交的内容

> 在这种隔离条件下，查询不会加锁，也由于查询的不加锁，所有这种隔离级别的一致性很差，会产生”脏读“、不可重复读，幻读--无特殊情况一般不会使用这种隔离方式

2. 读提交（read committed）：只能读到已提交的内容。

> 这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别
>
> 这种隔离级别能够有效的避免脏读，（不显示的在查询语句中加锁，普通的查询是不会加锁），利用的是”快照“机制
>
> 不能避免可重复读和幻读。

3. 可重复读：（Repeated Read)：针对”不可重复读“提出的解决方案（MySQL默认的隔离级别）

> 在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时，就不允许进行“修改操作（Update）”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的。
>
> 总结：可重复读：在当前事物中，如果不发生修改操作，则在该事物中前后读取到的数据应该是一致的，且不会读取到其他事物中提交或未提交的数据。

4. 串行化：(Serializable)

> 最高级别--这种级别下，事务”串行化顺序执行“，也就是一个一个排对执行
>
> 脏读，不可重复读，幻读都可以解决

#### 嵌套事务：

子事务嵌套在父事务中执行，子事务是父事务的一部分，在进入子事务前，父事务会建立一个回滚点。子事务会回滚到这个点

#### MySQL默认隔离级别

MySQL可重复读隔离级别的实现原理

https://www.cnblogs.com/lmj612/p/10598971.html

MySQL默认的隔离级别是可重复读，即：事务A在读到一条数据后，事务B对该数据进行了修改并提交，那么事务A在读该数据，读到的还是原来内容（如果不是则产生了不可重复读的问题）。

**实现方式：**使用一种MVCC（多版本并发控制，类似一种乐观锁）

1、 在读取事务开始时，系统会给当前读事务一个版本号，事务会读取版本号<=当前版本的数据

2、如果其他写事务修改了这条数据，那么这条数据的版本号就会加1，从而比当前读事务的版本号高，读事务就读不到更新后的数据

### 🏷 Innodb引擎和Myisam引擎

摘自[《深入理解 Mysql 索引底层原理》](https://zhuanlan.zhihu.com/p/113917726)

Mysql底层数据引擎以插件的形式设计的，最常见的是Innodb引擎和Myisam引擎，用户可以根据个人需求选择不同的引擎作为MySQL数据表的底层引擎。

Myisam虽然查找性能极佳，但是不支持事务处理。InNoDB最大的特色就是支持了ACID兼容的事务功能，而且他也支持行级锁。MySQL建立表的时候就可指定引擎，比如：

```sql
create table `user2` (
	`id` int(11) not null default `0`,
	`username` varchar(255) not null,
	primary key (`id`)
) ENGINE=myisam default charset = utf8;
create table `user` (
	`id` int(11) not null default `0`,
	`username` varchar(255) not null,
	primary key (`id`)
) ENGINE=InnoDB default charset = utf8; 
```

执行上述两个指令后，系统出现了以下文件，说明这两个引擎数据和索引的组织方式是不一样的。

![img](http://www.xyongs.cn/image/mysql_engine.png)

Innodb创建表后生成的文件有：

* frm: 创建表的语句
* idb：表里的数据+索引文件

Myisam创建后生成的文件有：

* frm：创建表的语句
* MYD：表里的数据文件（myisam data）
* MYI：表里的索引文件（myisam index）

从生成的文件上来看，这两个引擎底层数据和索引的组织方式并不一样，MyISAM引擎把数据和索引存在不同的文件，这叫做非聚集索引方式；InNoDB引擎把数据和引擎放在同一个文件里，这叫聚簇索引方式。下面将从底层实现角度分析这两个引擎是怎么依靠B+树这个数据结构来组织引擎实现的。

#### MyISAM引擎的底层实现（非聚集索引方式）

MyISAM用的是非聚类索引方式，即数据和索引落在不同的两个文件上。MyISAM在建表时以主键作为key来建立主索引的B+树，树的叶子节点存储的是对应数据的物理地址。我们拿到这个物理地址就可以到MyISAM数据文件中直接定位到具体的数据记录了。

![img](http://www.xyongs.cn/image/mysql_myisam.png)

当我们为某个字段添加索引时，我们同样会生成对应字段的索引树，该字段的索引树的子节点同样记录的了对应数据的物理地址，然后也是拿着物理地址去数据文件中定位到具体的位置。

#### InNoDB引擎的底层实现（聚集索引方式）

InNoDB是聚集索引方式，因此数据和索引都存储在同一个文件中。首先InNoDB会根据主键ID作为KEY建立索引B+树，而B+树的叶子节点存储的是主键ID对应的数据，比如在执行 `slect * from user_info where id = 5;` 这个语句式，InNoDB就会查询这棵主键ID索引B+树，找到对应的`user_name`。

这是建表的时候InNoDB就会自动建立好主键ID索引树，这也是为什么MySQL在建表时要求必须指定主键的原因，当我们给`user_name`这个字段加索引，那么InNoDB就会建立`user_name`索引B+树，节点里存储的是`user_name` 的 KEY，叶子节点存储的是主键KEY，拿到主键后，InNoDB才会去主键索引树中二次索引，找对对应的数据

![img](http://www.xyongs.cn/image/mysql_innodb.png)

**❓为什么InNoDB只在主键索引树的叶子节点存储了具体的数据，在其他索引树却不存在具体数据，而要多此一举先找到主键，再在主键索引树中找到对应数据？**

InNoDB需要节省存储空间。一个表里可能有很多个索引

#### 对比

MyISAM查询性能更好，从索引文件数据的设计可以看出：MyISAM直接找到物理地址，但是InNoDB查询到叶子节点后，还需要再次查询主键索引树。

#### ❓添加索引的时机？

1. 较频繁的作为查询条件的字段应该穿件索引；
2. 唯一性太差的字段不适合单独创建索引，即使该字段频繁作为查询条件；
3. 更新非常频繁的字段不适合创建索引。

### 🏷 数据库锁

MySQL三种锁：

表级锁

行级锁

页级锁

**死锁：只多个进程在执行过程中，因争夺资源而造成的一种等待现象，若无外力干预，他们无法进行下去**

悲观锁：

顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿到这个数据就会block直到它拿到锁。

传统的关系型数据库里边用到了很多这样的锁，行锁，表锁，读锁，写锁，都是在操作前先上锁的。

乐观锁：

每次去拿数据的时候都认为别人不会修改，所以不会上锁，但在更新的时候会判断在此期间别人有没有去更新这个数据，可以使用版本号等机制。

乐观锁适用于多读的场景，这样可以提高吞吐量

两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。

### 🏷 数据库Q&A

**问题1、为什么一定要设置一个主键？**

**A：**在你不设置主键的情况下，innodb也会帮你生成一个隐藏列，作为自增主键。并且在自建主键上能显式的用上主键索引，提高查询效率；

**问题2、主键用自增还是UUID？**

**A：**自增较好，innodb中的主键值聚簇索引，如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，引发页的分裂，产生表碎片

2.1、自增主键用完怎么办？

A:增大数据范围，如int 改为BigInt 

**问题3:主键为什么不推荐有业务含义?**

*回答*:有如下两个原因

- (1)因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。
- (2)带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。

**问题4:表示枚举的字段为什么不用enum类型？**

回答:在工作中表示枚举的字段，一般用tinyint类型。

那为什么不用enum类型呢？下面两个原因

(1)ENUM类型的ORDER BY操作效率低，需要额外操作

(2)如果枚举值是数值，有陷阱

问**题5:货币字段用什么类型?**

*回答:*如果货币单位是分，可以用Int类型。如果坚持用元，用Decimal。

千万不要答float和double，因为float和double是以二进制存储的，所以有一定的误差。

**问题6:时间字段用什么类型?**

*回答:*此题无固定答案，应结合自己项目背景来答！把理由讲清楚就行！

1. varchar，如果用varchar类型来存时间，优点在于显示直观。但是坑的地方也是挺多的。比如，插入的数据没有校验，你可能某天就发现一条数据为2013111的数据，请问这是代表2013年1月11日，还是2013年11月1日？其次，做时间比较运算，你需要用STR_TO_DATE等函数将其转化为时间类型，你会发现这么写是无法命中索引的。数据量一大，是个坑！
2. timestamp，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用timestamp类型存储的。但是它有一个优势，timestamp类型是带有时区信息的。一旦你系统中的时区发生改变，例如你修改了时区
3. datetime，datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！
4. bigint，也是8个字节，自己维护一个时间戳，表示范围比timestamp大多了，就是要自己维护，不大方便。

**问题7:为什么不直接存储图片、音频、视频等大容量内容?**

*回答:*我们在实际应用中，都是用HDFS来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件，也就是text和blob类型。但是，我们在生产中，基本不用这两个类型！

主要原因有如下两点

- (1)Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。导致查询效率缓慢
- (2)binlog内容太多。因为你数据内容比较大，就会造成binlog内容比较多。大家也知道，主从同步是靠binlog进行同步，binlog太大了，就会导致主从同步效率问题！

因此，不推荐使用text和blob类型！

**问题8:字段为什么要定义为NOT NULL?**

*回答:*OK，这问题从两个角度来答

(1)索引性能不好

**Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。**

**—— 出自《高性能mysql第二版》**

(2)查询会出现一些不可预料的结果

这里举一个例子，大家就懂了。假设，表结构如下

create table table_2 (     `id` INT (11) NOT NULL,    name varchar(20) NOT NULL )

表数据是这样的

| id   | name     |
| ---- | -------- |
| 1    | Sanzhang |
| 3    |          |
| 5    | Sili     |
| 7    |          |

你执行语句

select count(name) from table_2;

你会发现结果为2，但是实际上是有四条数据的！类似的查询问题，其实有很多，不一一列举。

记住，因为null列的存在，会出现很多出人意料的结果，从而浪费开发时间去排查Bug.

**面试题001：请解释关系型数据库概念及主要特点？**

关系型数据库模型是**把复杂的数据结构归结为简单的二元关系**，对数据的操作都是建立一个或多个关系表格上，**最大的特点就是二维的表格**，通过SQL结构查询语句存取数据，保持数据一致性方面很强大

**面试题002：请说出关系型数据库的典型产品、特点及应用场景？**

1、SQLserver：主机为Windows系统很好的适配Windows操作系统，主要应用于web网站的建设，承载中小型web后台数据

2、MySQL：高并发读写需求，网站的用户并发非常高，硬盘I/O是一个很大的瓶颈；

3、Oracle，夸平台，安全性能高，性能稳定，对硬件要求高，贵

**面试题003：请解释非关系型数据库概念及主要特点？**

非关系型数据库也被称为NoSQL数据库，数据存储不需有特有固定的表结构 特点：高性能、高并发、简单易安装

**面试题006：请详细描述char(4)和varchar(4)的差别**

char长度是固定不可变的，varchar长度是可变的（在设定内）比如同样写入cn字符，char类型对应的长度是4(cn+两个空格),但varchar类型对应长度是2

**面试题009：什么是MySQL多实例，如何配置MySQL多实例？**

mysql多实例就是在同一台服务器上启用多个mysql服务，它们监听不同的端口，运行多个服务进程，它们相互独立，互不影响的对外提供服务，便于节约服务器资源与后期架构扩展 多实例的配置方法有两种： 1、一个实例一个配置文件，不同端口 2、同一配置文件(my.cnf)下配置不同实例，基于mysqld_multi工具

**面试题010：如何加强MySQL安全，请给出可行的具体措施？**

1、删除数据库不使用的默认用户 2、配置相应的权限（包括远程连接） 3、不可在命令行界面下输入数据库的密码 4、定期修改密码与加强密码的复杂度

